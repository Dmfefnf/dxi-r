{
  "hash": "cdcbd255ac74e0182222d67105850632",
  "result": {
    "markdown": "---\n# bibliography: references.bib\n\nabstract: \"\"\n---\n\n\n# Boole'sche Operationen {#sec-chapter-booleans}\n\n::: {.callout-warning}\n## Work in Progress\n::: \n\n\n::: {.cell}\n\n:::\n\n\nIn R stehen die logischen Operationen als *binäre* Operatoren zur Verfügung, bzw. als Funktionen mit genau zwei Parametern. Diese logischen Operatoren sind vektorisiert. Es ist deshalb unnötig, logische Ausdrücke durch die Boole'sche Arithmetik zu ersetzen. Lediglich die Reihenfolge der Ausführung dieser Opeartoren folgt der gleichen Regel wie die Arithmetik. \n\n::: {.callout-note}\n## Merke\n* Das logische Und entspricht der Multiplikation.\n* Das logische Oder entspricht der Addition.\n:::\n\nDaraus folgt, dass immer zuerst das logische Und und erst danach das logische Oder ausgewertet wird. Dieser Regel folgt auch R. \n\nDie @tbl-logische-operatoren stellt die logischen Operationen und die verschiedenen Schreibweisen gegenüber.\n\n| Operation | neutrales Element |  Mathematisch |  R |  arithmetische Operation |\n| :--- | :--- | :--- | :---: | :---: |\n| Nicht | - | $$ \\lnot $$ |  `!`  | $1 - a$ | \n| Und | WAHR |  $$ \\land $$ | `&` |  $a \\cdot b$ | \n| Oder  | FALSCH | $$ \\lor $$ |  `|`  | $a + b$ |\n| Exklusiv-Oder/Antivalenz  |  - | $$ \\oplus $$ | `xor() `  |  (a - b)^2 |\n\n: Die wichtigsten logischen Operatoren und ihre Entsprechung in R {#tbl-logische-operatoren}\n\n::: {.callout-warning}\n## Achtung\nEs gibt neben den beiden Operatoren `&` und `|` auch die gedoppelte Varianten `&&` und `||`. Diese Varianten arbeiten auf den Binärwerten von Ganzzahlen und werden normalerweise **nicht** im Zusammenhang mit logischen Ausdrücken verwendet. \n::: \n\nDas **Logisches Nicht** wird in R durch den Nicht-Operator (`!`) ausgedrückt. Dieser Operator wird auf jeden Wert eines Vektors einzeln angewandt. \n\n::: {#exm-logisches-nicht}\n## Logisches Nicht\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogischer_vektor = c(TRUE, FALSE, FALSE, TRUE, TRUE)\n\n! logischer_vektor \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE FALSE FALSE\n```\n:::\n:::\n\n:::\n\nR wandelt numerische Werte automatisch in Wahrheitswerte um, wenn sie mit logischen Operationen verwendet werden. Dabei gilt: \n\n* `FALSE` entspricht `0`\n* `TRUE` entspricht *ungleich* `0`\n\n::: {#exm-autoconvert-not}\n\n::: {.cell}\n\n```{.r .cell-code}\n! c(1, 2, 0, 4, 0) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE  TRUE\n```\n:::\n:::\n\n:::\n\nWenn Sie in R zwei Vektoren mit dem Und- (`&`), dem Oder-Operator (`|`) oder der  Antivalenz (`xor()`) verknüpfen, dann werden die Werte **immer** *paarweise* miteinander verglichen. Ein einzelner Vektor kann nicht an die Funktion des jeweiligen Operators übergeben werden. \n\n**Beispiel paarweise Verknüpfung**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor_a = c(TRUE, FALSE, FALSE, TRUE, TRUE)\nvektor_b = c(TRUE,  TRUE, FALSE, FALSE, TRUE)\n\nvektor_a & vektor_b \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE FALSE  TRUE\n```\n:::\n:::\n\n## Logische Aggregationen mit `reduce()`\n\n::: {.callout-note}\n## Merke\nUm logische Vektoren in **R** zu aggregieren, muss der Vektor **reduziert** (engl. *reduce*) werden. Das *Reduzieren* ist eine besondere *Aggregation* über eine Reihe von Werten, bei der jeder Wert gemeinsam mit dem Ergebnis der Vorgängerwerte an eine Funktion übergeben wird.\n:::\n\n::: {#exm-logical-reduce}\n## Aggregation logischer Vektoren\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbeispielWerte = c(TRUE, TRUE, FALSE, TRUE)\n\nbeispielWerte |> reduce(`&`)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nbeispielWerte |> reduce(`|`)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nbeispielWerte |> reduce(`xor`) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\n::: {.callout-important}\nBeim Reduzieren muss beachtet werden, dass eine Funktion und nicht den Operator übergeben wird. Deshalb muss der jeweilige logische Operator in Backticks (`` ` ``) gesetzt und so als Funktionsbezeichner markiert werden. \n:::\n\n## Vergleiche \n\nNeben den logischen Operationen sind Vergleiche ein wichtiges Konzept, das wir in logischen Ausdrücken regelmässig anwenden. \n\nEs gibt genau sechs (6) Vergleichsoperatoren:\n\n* Gleich (`==`)\n* Ungleich (`!=`)\n* Grösser als (`>`)\n* Grösser gleich (`>=`)\n* Kleiner als (`<`)\n* Kleiner gleich (`<=`)\n\n::: {.callout-warning}\nVergleiche erfordern, dass beide Werte vom gleichen Datentyp sind.\n:::\n\nDie Vergleiche funktionieren für alle fundamentalen Datentypen.\n\nBei Zeichenketten wertet R die alphabetische Reihenfolge der Symbole vom Beginn einer Zeichenkette aus, um grösser oder kleiner Vergleiche durchzuführen.\n\n### Die Existenz eines Werts in einem Vektor überprüfen\n\nHäufig müssen Sie überprüfen, ob ein Wert in einer Liste vorkommt. Grundsätzlich können Sie das mit komplizierten logischen Verknüpfungen in der Art von @exm-check-without-in schreiben.\n\n::: {#exm-check-without-in}\n## Existstenzprüfung ohne `%in%`\n\n::: {.cell}\n\n```{.r .cell-code}\nmeinWert = 3\nwertVektor = c(8, 2, 3)\n\nmeinWert == wertVektor[1] | meinWert == wertVektor[2] | meinWert == wertVektor[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\nEinfacher ist aber ein sogenannter *Existenztest*. Dabei wird überprüft, ob ein Wert in einem Vektor vorkommt. Ein solcher Test lässt sich wie in @exm-check-with-in schreiben: \n\n::: {#exm-check-with-in}\n## Existstenzprüfung mit `%in%`\n\n::: {.cell}\n\n```{.r .cell-code}\nmeinWert = 3\nwertVektor = c(8, 2, 3)\n\nmeinWert %in% wertVektor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\nEntsprechend der Definition des Existenzvergleichs $\\in$ funktioniert R's `%in%`-Operator auch für Vektoren als linker Operand.\n\n## Fälle unterscheiden\n\n### Bedingte Operationen\n\n### Vektorisierte Unterscheidungen\n\n## Filter\n\n## Sortieren\n",
    "supporting": [
      "kapitel_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}