{
  "hash": "1e6fc8805aab5686b1d7fecf942bcf78",
  "result": {
    "markdown": "---\n# bibliography: references.bib\n\nabstract: \"\"\n---\n\n\n\n# Boole'sche Operationen {#sec-chapter-booleans}\n\n::: {.callout-warning}\n## Work in Progress\n::: \n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\nIn R stehen die logischen Operationen als *binäre* Operatoren zur Verfügung, bzw. als Funktionen mit genau zwei Parametern. Diese logischen Operatoren sind vektorisiert. Es ist deshalb unnötig, logische Ausdrücke durch die Boole'sche Arithmetik zu ersetzen. Lediglich die Reihenfolge der Ausführung dieser Opeartoren folgt der gleichen Regel wie die Arithmetik. \n\n::: {.callout-note}\n## Merke\n* Das logische Und entspricht der Multiplikation.\n* Das logische Oder entspricht der Addition.\n:::\n\nDaraus folgt, dass immer zuerst das logische Und und erst danach das logische Oder ausgewertet wird. Dieser Regel folgt auch R. \n\nDie @tbl-logische-operatoren stellt die logischen Operationen und die verschiedenen Schreibweisen gegenüber.\n\n| Operation | neutrales Element |  Mathematisch |  R |  arithmetische Operation |\n| :--- | :--- | :--- | :---: | :---: |\n| Nicht | - | $$ \\lnot $$ |  `!`  | $1 - a$ | \n| Und | WAHR |  $$ \\land $$ | `&` |  $a \\cdot b$ | \n| Oder  | FALSCH | $$ \\lor $$ |  `|`  | $a + b$ |\n| Exklusiv-Oder/Antivalenz  |  - | $$ \\oplus $$ | `xor() `  |  (a - b)^2 |\n\n: Die wichtigsten logischen Operatoren und ihre Entsprechung in R {#tbl-logische-operatoren}\n\n::: {.callout-warning}\n## Achtung\nEs gibt neben den beiden Operatoren `&` und `|` auch die gedoppelte Varianten `&&` und `||`. Diese Varianten arbeiten auf den Binärwerten von Ganzzahlen und werden normalerweise **nicht** im Zusammenhang mit logischen Ausdrücken verwendet. \n::: \n\nDas **Logisches Nicht** wird in R durch den Nicht-Operator (`!`) ausgedrückt. Dieser Operator wird auf jeden Wert eines Vektors einzeln angewandt. \n\n::: {#exm-logisches-nicht}\n## Logisches Nicht\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogischer_vektor = c(TRUE, FALSE, FALSE, TRUE, TRUE)\n\n! logischer_vektor \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\n:::\n\nR wandelt numerische Werte automatisch in Wahrheitswerte um, wenn sie mit logischen Operationen verwendet werden. Dabei gilt: \n\n* `FALSE` entspricht `0`\n* `TRUE` entspricht *ungleich* `0`\n\n::: {#exm-autoconvert-not}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n! c(1, 2, 0, 4, 0) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE  TRUE\n```\n:::\n:::\n\n\n:::\n\nWenn Sie in R zwei Vektoren mit dem Und- (`&`), dem Oder-Operator (`|`) oder der  Antivalenz (`xor()`) verknüpfen, dann werden die Werte **immer** *paarweise* miteinander verglichen. Ein einzelner Vektor kann nicht an die Funktion des jeweiligen Operators übergeben werden. \n\n**Beispiel paarweise Verknüpfung**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor_a = c(TRUE, FALSE, FALSE, TRUE, TRUE)\nvektor_b = c(TRUE,  TRUE, FALSE, FALSE, TRUE)\n\nvektor_a & vektor_b \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE FALSE  TRUE\n```\n:::\n:::\n\n\n## Logische Aggregationen mit `reduce()`\n\n::: {.callout-note}\n## Merke\nUm logische Vektoren in **R** zu aggregieren, muss der Vektor **reduziert** (engl. *reduce*) werden. Das *Reduzieren* ist eine besondere *Aggregation* über eine Reihe von Werten, bei der jeder Wert gemeinsam mit dem Ergebnis der Vorgängerwerte an eine Funktion übergeben wird.\n:::\n\n::: {#exm-logical-reduce}\n## Aggregation logischer Vektoren\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbeispielWerte = c(TRUE, TRUE, FALSE, TRUE)\n\nbeispielWerte |> reduce(`&`)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nbeispielWerte |> reduce(`|`)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nbeispielWerte |> reduce(`xor`) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-important}\nBeim Reduzieren muss beachtet werden, dass eine Funktion und nicht den Operator übergeben wird. Deshalb muss der jeweilige logische Operator in Backticks (`` ` ``) gesetzt und so als Funktionsbezeichner markiert werden. \n:::\n\n## Vergleiche \n\nNeben den logischen Operationen sind Vergleiche ein wichtiges Konzept, das wir in logischen Ausdrücken regelmässig anwenden. \n\nEs gibt genau sechs (6) Vergleichsoperatoren:\n\n* Gleich (`==`)\n* Ungleich (`!=`)\n* Grösser als (`>`)\n* Grösser gleich (`>=`)\n* Kleiner als (`<`)\n* Kleiner gleich (`<=`)\n\n::: {.callout-warning}\nVergleiche erfordern, dass beide Werte vom gleichen Datentyp sind.\n:::\n\nDie Vergleiche funktionieren für alle fundamentalen Datentypen.\n\nBei Zeichenketten wertet R die alphabetische Reihenfolge der Symbole vom Beginn einer Zeichenkette aus, um grösser oder kleiner Vergleiche durchzuführen.\n\n### Die Existenz eines Werts in einem Vektor überprüfen\n\nHäufig müssen Sie überprüfen, ob ein Wert in einer Liste vorkommt. Grundsätzlich können Sie das mit komplizierten logischen Verknüpfungen in der Art von @exm-check-without-in schreiben.\n\n::: {#exm-check-without-in}\n## Existstenzprüfung ohne `%in%`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeinWert = 3\nwertVektor = c(8, 2, 3)\n\nmeinWert == wertVektor[1] | meinWert == wertVektor[2] | meinWert == wertVektor[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n:::\n\nEinfacher ist aber ein sogenannter *Existenztest*. Dabei wird überprüft, ob ein Wert in einem Vektor vorkommt. Ein solcher Test lässt sich wie in @exm-check-with-in schreiben: \n\n::: {#exm-check-with-in}\n## Existstenzprüfung mit `%in%`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeinWert = 3\nwertVektor = c(8, 2, 3)\n\nmeinWert %in% wertVektor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n:::\n\nEntsprechend der Definition des Existenzvergleichs $\\in$ funktioniert R's `%in%`-Operator auch für Vektoren als linker Operand.\n\n## Fälle unterscheiden\n\n### Bedingte Operationen\n\nR kennt die beiden Schlüsselworte `if` und `else`, um die Ausführung Operationsblöcken an Bedingungen zu knüpfen. Das Schlüsselwort `if` erwartet einen logischen Ausdruck, der **genau** einen Wahrheitswert zurückgibt. Logische Ausdrücke mit Vektoren sind damit nicht möglich. \n\nSoll sowohl die Bedingung als auch die Alternative behandelt werden, dann muss das Schlüsselwort `else` in der gleichen Zeile stehen, wie das Ende des Blocks für die Bedingung.\n\n::: {#exm-ungueltiges-if}\n## Ungültige Vektorbedingung mit `if`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwerte = c(-1, 2, 0, 1)\n\nif (werte > 1) {\n    werte = werte - 1\n} else {\n    werte = 0\n}\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in if (werte > 1) {: Bedingung hat Länge > 1\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-tip}\n## Praxis\nBedingte Operationen sind in R nur selten notwendig. Die einzige relevandte Anwendung ist Datentypkontrolle für Parameter bevor die eigentliche Operation durchgeführt wird. \n:::\n\n::: {#exm-datentyppruefung-if}\n## Datentypprüfung mit `if`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!is.list(werte)) {\n    stop(\"Variable enthält keine Liste\")\n}\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Variable enthält keine Liste\n```\n:::\n:::\n\n\n:::\n\n### Vektorisierte Unterscheidungen\n\nHäufiger als Bedingungen kommen in R vektorisierte Unterscheidungen vor. Dafür stehen zwei Funktionen zur Verfügung:\n\n- `ifelse()`\n- `case_when()`\n\nDie Funktion `ifelse()` hat drei Parameter und immer einen Vektor als Ergebnis. Die Parameter sind:\n\n1. Einen vektorisierten logischen Ausdruck.\n2. Eine Operation für den Fall, dass der logische Ausdruck Wahr (`TRUE`) ergibt.\n3. Eine Opearation für den Fall, dass der logische Ausdruck Falsch (`FALSE`) ergibt.\n\nDie Ergebnisse der beiden Operationen stehen im Ergebnisvektor an den Positionen, an denen der logische Ausdruck Wahr oder Falsch ergab. \n\n::: {#exm-ifelse}\n## Vektorisierte Unterscheidung mit `ifelse()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nifelse(werte > 1, werte * 2, 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 4 0 0\n```\n:::\n:::\n\n\n:::\n\nDie Funktion `case_when()` erlaubt es, mehrere miteinander verbundene vektorisierte Unterscheidungen in einer Operation durchzuführen. Dazu werden logische Ausdrücke mit Ergebnisoperationen bzw. -Werten verknüpft. Eine Ergebnisoperation wird dann ausgeführt, wenn der zugehörige logische Ausdruck Wahr (`TRUE`) ergibt. Die logischen Ausdrücke werden in der angegebenen Reihenfolge geprüft, wobei die Operation abbricht, sobald ein logischer Ausdruck Wahr ergibt. \n\n::: {#exm-case-when-default}\n## `case_when()` über einen Vektor\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_when(\n    werte > 0 ~ \"positiv\",\n    werte == 0 ~ \"null\",\n    werte < 0 ~ \"negativ\" \n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"negativ\" \"positiv\" \"null\"    \"positiv\"\n```\n:::\n:::\n\n\n:::\n\nFür den Fall, dass für einen Wert kein logischer Ausdruck Wahr ergibt, kann ein **Rückfallergebnis** angegeben werden. Dieses Rückfallergebnis muss mit `.default =` eingeleitet werden. \n\n::: {#exm-case-when-default}\n## `case_when()` mit Rückfallergebnis\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_when(\n    werte > 0 ~ \"positiv\",\n    werte < 0 ~ \"negativ\",\n    .default = \"null\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"negativ\" \"positiv\" \"null\"    \"positiv\"\n```\n:::\n:::\n\n\n\n:::\n\n## Filtern\n\nDas Filtern von Werten in Vektoren und Stichproben ist ein zentrales Element von R. Dafür stehen viele Funktionen bereit. Es ist auch möglich über die Index-Operatoren zu filtern.\n\nIn der Praxis wird meistens die Funktion `filter()` zum Auswählen von Datensätzen verwendet. Diese Funktion ermöglicht es, einen Datenrahmen mittels eines logischen Ausdrucks einzuschränken. Die Funktion `filter()` hat zwei Parameter: \n\n1. Den Datenrahmen und\n2. Den logischen Ausdruck für die Auswahl der Datensätze. \n\nDas Ergebnis ist ein Datenrahmen, der nur Datensätze enthält, für die der logische Ausdruck Wahr (`TRUE`) ergibt.\n\n> ::: {#exm-filter}\n> ## Filtern\n> \n> | | A | B | C |\n> | :---: | :---| :---: |  :---: | \n> | **1** | *Name* | *Sprache* | *Einwohner:innen* |\n> | **2** | Basel | deutsch | 173863| \n> | **3** | Genf | französisch | 203856 | \n> | **4** | Lugano | italienisch | 62315 | \n> | **5** | Zug | deutsch | 30934 | \n> | **6** | Zürich | deutsch | 421878 | \n> \n> Für diese Stichprobe möchten wir wissen, wie viele Einwohner in Städten mit mehr als 100000 Einwohnenden leben?\n> \n> Diese Frage beantworten wir mit der folgenden Logik:\n> \n> 1. Alle Städte mit mehr als 100000 Einwohner:innen filtern.  \n> 2. Die Einwohner:innen der gefilterten Städte zusammenzählen. \n> \n> Der logische Ausdruck zum Filtern ist `` `Einwohner:innen` > 100000 ``, weil dieser Ausdruck nur für die Datensätze Wahr wird, wenn im Vektor `Einwohner:innen` der Wert grösser als `100000` ist. Nach dem Filtern im ersten Schritt liegt nur noch die folgende Stichprobe vor: \n> \n> | | A | B | C |\n> | :---: | :---| :---: |  :---: | \n> | **1** | *Name* | *Sprache* | *Einwohner:innen* |\n> | **2** | Basel | deutsch | 173863 | \n> | **3** | Genf | französisch | 203856 | \n> | **6** | Zürich | deutsch | 421878 | \n> \n> Für diese Teilstichprobe muss im zweiten Schritt nur noch die Summe über den Vektor `Einwohner:innen` gebildet werden. \n> \n> Daraus ergibt sich die folgende Funktionskette: \n> \n> ::: {.cell warnings='false'}\n> \n> ```{.r .cell-code}\n> read_delim(\"daten/einwohnende.psv\", \n>            delim = \"|\", \n>            trim_ws = T, \n>            show_col_types = F) |> \n>     filter(`Einwohner:innen` > 100000) |>\n>     summarise(\n>         Gesamteinwohnende = sum(`Einwohner:innen`)\n>     )\n> ```\n> \n> ::: {.cell-output .cell-output-stdout}\n> ```\n> # A tibble: 1 x 1\n>   Gesamteinwohnende\n>               <dbl>\n> 1            799597\n> ```\n> :::\n> :::\n> :::\n\n\n### `NA`-Werte filtern \n\nDie Funktion `drop_na()` ist eine spezielle Filterfunktion, deren Ergebnis nur Datensätze enthält, in denen bei keinem Vektor den Wert `NA` vorkommt. Die Funktion hat keinen Effekt, wenn ein Datenrahmen nur gültige Werte enthält (@exm-drop-na-all).\n\n::: {#exm-drop-na-all}\n## `drop_na()` ohne Effekt\n:::\n\n## Selektieren\n\n::: {.callout-tip}\n## Praxis\n\nDie `tidyverse` Bibliothek umfasst die [`tidyselect`-Funktionen](https://tidyselect.r-lib.org/reference/language.html). Dabei handelt es sich um eine Reihe von Hilfsfunktionen, die die Vektorenauswahl nachvollziehbarer macht. Auf der [`tidyselect`-Homepage](https://tidyselect.r-lib.org/) finden sich ausführliche Code-Beispiele. \n:::\n\nIn R können Vektoren mit der Funktion `select()` selektiert werden. Dieser Funktion werden Regeln übergeben, nach denen die Vektoren auswählt werden sollen. Die einfachste Regel ist die direkte Eingabe der Vektorennamen. Ein typischer Anwendungsfall ist die Datenbereinigung, damit die Funktion `drop_na()` nicht zu viele Datensätze löscht. Diese Situation kommt vor, wenn ein Datenrahmen viele fehlende Werte enthält, die ungleichmässig in den Vektoren vorkommen. Die Analyse muss deshalb auf die gewünschten Vektoren beschränkt werden. \n\nFür die folgenden Beispiele verwenden wir die Daten der Befragung zum digitalen Umfeld, die mit der `read_delim()`-Funktion eingelesen wird. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe = read_delim(\"daten/befragung_digitales_umfeld/deviceuse.csv\") \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 76 Columns: 4\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (4): q00_demo_gen, q00_demo_studyload, q01_mob_typ, q12_fav_apps\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n\n### Vektoren direkt selektieren\n\nWir wollen die Vektoren `q00_demo_gen` (Gender), `q00_demo_studyload` (Studienmodell) und `q01_mob_typ` (Mobile OS des Smartphones) auswählen. \n\n::: {#exm-select-direkt}\n## Direktes selektieren\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe |>\n    select(q00_demo_gen, q00_demo_studyload, q01_mob_typ) |>\n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n  q00_demo_gen q00_demo_studyload q01_mob_typ       \n  <chr>        <chr>              <chr>             \n1 Weiblich     Vollzeit           iPhone            \n2 Weiblich     Vollzeit           iPhone            \n3 Weiblich     Teilzeit           iPhone            \n4 Weiblich     Teilzeit           iPhone            \n5 Männlich     <NA>               Android Smartphone\n6 Weiblich     Vollzeit           iPhone            \n```\n:::\n:::\n\n\n:::\n\nDurch diesen Aufruf von `select()` wird der Datenrahmen auf die drei ausgewählten Vektoren reduziert. \n\n### Alle ausser die benannten Vektoren selektieren\n\nVektoren direkt zu benennen ist eine einfache direkte Methode. Wenn man sehr viele Vektoren auswählen möchte, dann ist es manchmal einfacher, nur die Vektoren anzugeben, die *nicht* in der Ergebnisstichprobe enthalten sein sollen. Mit `select()` erreichen wir das, indem wir ein `-` den ungewollten Vektoren voranstellen. \n\nDas folgende Beispiel selektiert alle Vektoren ausser `q00_demo_gen` aus der Stichprobe. \n\n::: {#exm-select-direkt-neg}\n## Selektieren durch Ausschliessen\n```R\nstichprobe |>\n    select(-q00_demo_gen) |>\n    head()\n```\n:::\n\nWenn  mehrere Vektoren ausgeschlossen werden sollen, dann müssen diese zu einem Vektor zusammengefasst werden. \n\n::: {#exm-select-direkt-neg-multi}\n## Selektieren durch mehrfaches Ausschliessen\n```R\nstichprobe |>\n    select(- c(q00_demo_gen, q00_demo_studyload)) |>\n    head()\n```\n:::\n\nDiese Vektorenauswahl wählt alle Vektoren ausser das Geschlecht und das Studienmodell. \n\n### Vektoren mit ähnlichen Namen auswählen\n\nDrei leistungsfähige Hilfsfunktionen für `select()` sind: \n\n- `starts_with()`,\n- `ends_with()` sowie\n- `contains()`\n\nDiesen Funktionen akzeptieren einen Teilnamen, über den mehrere Vektoren ausgewählt werden, in denen der angegebene Teil im Vektornamen vorkommt. \n\nDiese Funktionen lassen sich mittels der `iris`-Stichprobe  veranschaulichen.\n\n::: {#exm-select-starts-with}\n## Selektieren mit `starts_with()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |>\n    select(starts_with(\"Sepal\")) |>  # wählt die Vektoren Sepal.Width und Sepal.Length aus\n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width\n1          5.1         3.5\n2          4.9         3.0\n3          4.7         3.2\n4          4.6         3.1\n5          5.0         3.6\n6          5.4         3.9\n```\n:::\n:::\n\n\n:::\n\n::: {#exm-select-ends-with}\n## Selektieren mit `ends_with()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |>\n    select(ends_with(\"Length\")) |> # wählt die Vektoren Petal.Length und Sepal.Length aus\n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Petal.Length\n1          5.1          1.4\n2          4.9          1.4\n3          4.7          1.3\n4          4.6          1.5\n5          5.0          1.4\n6          5.4          1.7\n```\n:::\n:::\n\n\n:::\n\n### Alle Vektoren zwischen zwei benannten Vektoren auswählen\n\nEine weitere Möglichkeit schneller viele Vektoren auszuwählen ist der `:`-Operator. Damit können wir alle Vektoren zwischen zwei Vektoren inklusive der benannten Vektoren auswählen.\n\nDer folgende Aufruf veranschaulicht dies: \n::: {#exm-select-range}\n## Vektorenbereich selektieren\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe |>\n    select(q00_demo_gen:q01_mob_typ) |>\n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n  q00_demo_gen q00_demo_studyload q01_mob_typ       \n  <chr>        <chr>              <chr>             \n1 Weiblich     Vollzeit           iPhone            \n2 Weiblich     Vollzeit           iPhone            \n3 Weiblich     Teilzeit           iPhone            \n4 Weiblich     Teilzeit           iPhone            \n5 Männlich     <NA>               Android Smartphone\n6 Weiblich     Vollzeit           iPhone            \n```\n:::\n:::\n\n\n:::\n\nDiese Vektorenauswahl wählt die Vektoren `q00_demo_gen`, `q00_demo_studyload` und `q01_mob_typ` für das Ergebnis aus.\n\n::: {.callout-warning}\nDie Reihenfolge von Vektoren kann durch andere Transformationen geändert werden. Deshalb sollte das Selektieren mit Vektorbereichen vermieden werden.\n:::\n\n## Sortieren\n\nR erlaubt kein Sortieren über logische Ausdrücke. Es ist nur möglich, Werte nach vorgegebenen grösser-kleiner Beziehungen zu sortieren. Deshalb muss für komplexe Sortierungen ein numerischer Hilfsvektor erzeugt werden, der anschliessend sortiert werden kann.  \n\nDie Werte eines Vektors werden mit `sort()` sortiert. \n\n::: {#exm-sort}\n## Vektorsortierung für zufällige Ganzzahlen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(10)\nrunif(10, min = 1, max = 10) |> trunc() |> sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 3 3 3 3 4 4 5 6 7\n```\n:::\n:::\n\n\n::: \n\nDie `sort()`-Funktion kann nur einzelne Vektoren sortieren. Das ist unpraktisch, wenn Daten in einem Datenrahmen vorliegen. In diesem Fall lassen sich die Datensätze mithilfe der Funktion `arrange()` sortieren. Der Funktion werden die Vektoren übergeben, über die eine neue Reihenfolge festgelegt werden soll. Standardmässig sortiert `arrange()` aufsteigend. Mit der Hilfsfunktion `desc()` (engl. descending = absteigen) werden Datensätze entsprechend der Werte im Sortiervektor absteigend sortiert.\n\n\n::: {#exm-sort}\n## Absteigende Datenrahmensortierung mit `arrange()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n    as_tibble(rownames = \"model\") |> \n    select(model, hp, disp, mpg, am) |> \n    arrange(desc(hp)) |> \n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 5\n  model                  hp  disp   mpg    am\n  <chr>               <dbl> <dbl> <dbl> <dbl>\n1 Maserati Bora         335   301  15       1\n2 Ford Pantera L        264   351  15.8     1\n3 Duster 360            245   360  14.3     0\n4 Camaro Z28            245   350  13.3     0\n5 Chrysler Imperial     230   440  14.7     0\n6 Lincoln Continental   215   460  10.4     0\n```\n:::\n:::\n\n\n::: \n",
    "supporting": [
      "kapitel_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}