{
  "hash": "b109f5ce5626d2fcd4638e1a7e60028f",
  "result": {
    "markdown": "---\n# bibliography: references.bib\n\nabstract: \"\"\n\n---\n\n\n\n# Daten beschreiben {#sec-chapter-daten-beschreiben}\n\n::: {.callout-warning}\n## Work in Progress\n:::\n\n\n\n\n\n\nie Funktionen zur Ermittlung der Kennzahlen von Datenrahmen werden durch die Bibliothek `rstatix` bereitgestellt. `rstatix` ist eine Bibliothek, die die am häufigsten verwendeten statistischen Operationen und Tests in Abstimmung mit den `tidyverse`-Bibliotheken bereitstellt. \n\n::: {.callout-important}\n## Achtung\n\n`rstatix` ist eine eigenständige Bibliothek und muss separat mit `install.packages()` oder `pak::pkg_install()` installiert werden.\n::: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n-- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\nv dplyr     1.1.2     v readr     2.1.4\nv forcats   1.0.0     v stringr   1.5.0\nv ggplot2   3.4.2     v tibble    3.2.1\nv lubridate 1.9.2     v tidyr     1.3.0\nv purrr     1.0.1     \n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\ni Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(rstatix)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttache Paket: 'rstatix'\n\nDas folgende Objekt ist maskiert 'package:stats':\n\n    filter\n```\n:::\n:::\n\n\n\n## Universelle Kennwerte\n\nIn R ergibt sich dieser Wert direkt aus dem Datenrahmen: Der **Stichprobenumfang** entspricht der **Anzahl der Datensätze** in unserem Stichprobenobjekt. Diese Anzahl bestimmen wir mit Hilfe der `count()`-Funktion oder innerrhalb einer Transforrmation mit `mutate()` mit Hilfe der `n()`-Funktion.\n\n::: {#exm-univ-kennwerte-daten}\n## Beispieldaten für die universellen Kennwerte\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe = read_csv2('data_ab_missing.csv')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ni Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 156 Columns: 4\n-- Column specification --------------------------------------------------------\nDelimiter: \";\"\nchr (1): Angebot\ndbl (3): Punkte, Interesse, Bedeutung\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n::: \n\nDer *Stichprobenumfang* ist einer der drei allgemeinen Kennwerte, die jede Stichprobe beschreiben. Wir bestimmen zuerst die numerischen Kennwerte unserer Beispielstichprobe.\n\n::: {.callout-warning}\n## Wichtig\nDie beiden universellen Kennwerte werden beim Import ebenfalls **angezeigt**. Diese Werte stehen für das automatisierte Reporting nicht zur Verfügung. Deshalb müssen diese Kennwerte noch einmal bestimmt werden.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Stichprobenumfang\nstichprobe |> \n    count() |> \n    pull() -> stichprobenumfang\n\nstichprobenumfang\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 156\n```\n:::\n\n```{.r .cell-code}\nstichprobe |> \n    names() |> \n    length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n\nDabei erkennen wir, dass der Stichprobenumfang 156 beträgt. Wir erkennen zusätzlich, dass wir 4 Vektoren in unserem Stichprobenobjekt vorliegen haben. Die Funktion `dim()` funktioniert auch für Datenrahmen, so dass die beiden Kennwerte auch mit dieser Funktion bestimmt werden können. Das Ergebnis `dim()` Funktion gibt als ersten Wert immer den Stichprobenumfang und als zweiten Wert den Umfang der Umfang der Vektoren zurück.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe |> \n    dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 156   4\n```\n:::\n:::\n\n\n\n## Variablenumfang und fehlende Werte\n\nNeben dem *Stichprobenumfang* werden zusätzlich die *Variablenumfänge* ermittelt. Der **Variablenumfang** bezeichnet die **Anzahl der *gemessenen* Merkmalsausprägungen**. Damit ist die Gesamtzahl der gemessenen Werte für ein Merkmal in einem Vektor gemeint. Für diesen Wert müssen die *nicht vorhandene* Werte aus der Variable entfernt werden. Diese Werte sind in R mit dem Wert `NA` gekennzeichnet. \n\nDie `NA`-Werte werden in R mithilfe der `drop_na()`-Funktion aus einem Datenrahmen entfernt. Die Funktion `drop_na()` entfernt alle *Datensätze*, in denen ein Vektor keinen Wert enthält. Das ist für den Variblenumfang nicht erwünscht. \n\nStatdessen werden die fehlenden Werte bei einer *Aggregaion* mit `na.omit()` ausgeblendet. \n\n::: {.callout-tip}\n## Praxis\n\nDie Variablenumfänge werden normalerweise gemeinsam mit den Lagemassen des Merkmals präsentiert.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe |>\n    summarise(\n        n_Punkte = Punkte |> na.omit() |> length(),\n        n_Angebot = Angebot |> na.omit() |> length(),\n        n_Interesse = Interesse |> na.omit() |> length(),\n        n_Bedeutung = Bedeutung |> na.omit() |> length()\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 4\n  n_Punkte n_Angebot n_Interesse n_Bedeutung\n     <int>     <int>       <int>       <int>\n1      153       152         151         150\n```\n:::\n:::\n\n\n\n## Lagemasse \n\nR stellt als Programmiersprache für die Data Sciences zentrale Funktionen zur Beschreibung von Daten direkt bereit. Es ist deshalb *in der Regel* nicht notwendig, die Formeln für die Lagemasse zu implementieren. @tbl-lagemasse liestet die Funktionen für die einzelnen Lagemasse.\n\n::: {.callout-note}\n## Merke\n\nAlle Lagemasse sind Aggregationen.\n::: \n\n| Mass | Funktion |\n| :--- | :--- |\n| Mittelwert | `mean()` |\n| Median | `median()` |\n| Standardabweichung | `sd()` |\n| Varianz | `var()` |\n| Interquartilsabstand | `IQR()` |\n| Mittlere Absolute Abweichung | `mad()` |\n| Quartile | `quantile()` |\n| Standardfehler | `sd(x) / sqrt(length(x))` |\n\n: R-Funktionen für die Lagemasse {#tbl-lagemasse}\n\nDer Standardfehler hat in Base-R keine eigene Funktion, sondern muss über die Standardabweichung hergeleitet werden. \n\nDie statistischen Kennwerte lassen sich also leicht mit der Aggregation in @exm-alle-kennwerte bestimmen.\n\n::: {#exm-alle-kennwerte}\n## Alle Kennwerte bestimmen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe |>\n    summarise(\n        n = Punkte |> na.omit() |> length(),\n        mn = Punkte |> mean(na.rm = TRUE),\n        sd = Punkte |> sd(na.rm = TRUE),\n        se = sd/sqrt(n),\n        min = Punkte |> min(na.rm = TRUE),\n        max = Punkte |> max(na.rm = TRUE),\n        q1 = Punkte |> quantile(.25, na.rm = TRUE),\n        md = Punkte |> median(na.rm = TRUE),\n        q3 = Punkte |> quantile(.75, na.rm = TRUE),\n        mad = Punkte |> mad(na.rm = TRUE),\n        iqr = Punkte |> IQR(na.rm = TRUE)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 11\n      n    mn    sd    se   min   max    q1    md    q3   mad   iqr\n  <int> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1   153  199.  69.7  5.64  16.5  395.  158.  196.  250.  68.8  92.2\n```\n:::\n:::\n\n\n::: \n\nNoch einfacher lassen sich die Kennwerte mit der Funktion `get_summary_stats()` aus der Bibliothek `rstatix` ermitteln (@exm-alle-kennwerte-rstatix). Ein wichtiger Vorteil dieser Funktion ist, dass sie ungültige Werte korrekt entfernt.\n\n::: {#exm-alle-kennwerte-rstatix}\n## Alle Kennwerte mit rstatix bestimmen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe |>\n    get_summary_stats(Punkte)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 13\n  variable     n   min   max median    q1    q3   iqr   mad  mean    sd    se\n  <fct>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Punkte     153  16.5  395.   196.  158.  250.  92.2  68.8  199.  69.7  5.64\n# i 1 more variable: ci <dbl>\n```\n:::\n:::\n\n\n:::\n\nFür ordinalskalierte Daten sind nicht alle Kennwerte zulässig. Deshalb dürfen für diese Daten nur die zulässigen Werte berichtet werden. Der Funktion `get_summary_stats()` müssen deshalb die zulässigen Kennwerte angegeben werden (@exm-kennwerte-ordskala-rstatix).\n\n::: {#exm-kennwerte-ordskala-rstatix}\n## Alle Kennwerte für ordinalskalierte Daten bestimmen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkennwerte_ordinal = c(\n    \"n\", \"min\", \"max\", \"median\", \"mad\", \"iqr\", \"q1\", \"q3\"\n)\n\nstichprobe |>\n    get_summary_stats(\n        -Punkte, # Alle Vektoren ausser Punkte\n        show = kennwerte_ordinal\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 9\n  variable      n   min   max median   mad   iqr    q1    q3\n  <fct>     <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Interesse   151     1     7      4  1.48   1.5     3   4.5\n2 Bedeutung   150     1     6      3  1.48   2       2   4  \n```\n:::\n:::\n\n\n:::\n\n::: {.callout-warning}\n## Wichtig\n\nOrdinalskalierte Daten müssen als numerische Werte *kodiert* vorliegen, damit die Kennwerte bestimmt werden können. Damit die Kennwerte interpretiert werden können, müssen alle verwendeten Kodierungstabelle ebenfalls berichtet werden. \n:::\n\n### Kennwerte über das Datenschema bestimmen\n\nDas Datenschema ist ein zentraler Teil der technischen Dokumentation eines Projekts. Liegt das Datenschema als Tabelle vor und die Skalierungen sind in einer eigenen Spalte dokumentiert, dann kann das Datenschema zur Beschreibung der Daten eingesetzt werden.\n\n@exm-datenschema-dataab zeigt ein reduziertes Datenschema für die geladenen Daten. Normalerweise würde dieses Schema aus einer Datei geladen werden. \n\n::: {#exm-datenschema-dataab}\n## Reduziertes Datenschema für die Daten\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# datenSchema = read_csv(\"datenschema.csv\")\ndatenSchema = tribble( \n    ~Name, ~Skalierung,\n    \"Punkte\", \"metrisch\",\n    \"Angebot\", \"nominal\",\n    \"Interesse\", \"ordinal\",\n    \"Bedeutung\", \"ordinal\"\n)\n```\n:::\n\n\n:::\n\nNachdem das Schema geladen wurde, können die Namen der Vektoren des gleichen Skalenniveaus gefiltert werden und an die Selektorfunktion `all_of()` übergeben werden (s. @exm-stats-with-schema). Auf diese Weise wird der Funktion `get_summary_stats()` mitgeteilt, für welche Vektoren die Kennwerte bestimmt werden sollen.\n\n::: {#exm-stats-with-schema}\n## Verwendung des Datenschames zur Beschreibung der Daten\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Metrisch-skalierte Kennwerte\nstichprobe |> \n    get_summary_stats(\n        datenSchema |> \n            filter(Skalierung == \"metrisch\") |> \n            pull(Name) |>\n            all_of()\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 13\n  variable     n   min   max median    q1    q3   iqr   mad  mean    sd    se\n  <fct>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Punkte     153  16.5  395.   196.  158.  250.  92.2  68.8  199.  69.7  5.64\n# i 1 more variable: ci <dbl>\n```\n:::\n\n```{.r .cell-code}\n# Ordinalskalierte Kennwerte\nstichprobe |> \n    get_summary_stats(\n        datenSchema |> \n            filter(Skalierung == \"ordinal\") |> \n            pull(Name) |>\n            all_of()\n        ,\n        show = kennwerte_ordinal\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 9\n  variable      n   min   max median   mad   iqr    q1    q3\n  <fct>     <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Interesse   151     1     7      4  1.48   1.5     3   4.5\n2 Bedeutung   150     1     6      3  1.48   2       2   4  \n```\n:::\n:::\n\n\n:::\n\n## Kontinenztabellen erstellen\n\nIn @sec-chapter-matrix-operationen wurden Kontingenztabellen eingeführt und die Funktion `table()` für zwei unabhängige Vektoren vorgestellt.\n\nFür Datenrahmen ist die Funktion `freq_table()` etwas flexibler und unterliegt nicht der Beschränkung auf zwei Vektoren. Ausserdem bestimmt die Funktion `freq_table()` automatisch die relativen Häufigkeiten. \n\n::: {#exm-kontingenztabelle-einzeln}\n## Kontingenztabelle für ein Merkmal\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe |>\n    freq_table(Angebot)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  Angebot     n  prop\n  <chr>   <int> <dbl>\n1 A          69  45.4\n2 B          83  54.6\n```\n:::\n:::\n\n\n:::\n\n::: {#exm-kontingenztabelle-mehrfach}\n## Kontingenztabelle für zwei Merkmale\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe |>\n    freq_table(Angebot, Bedeutung)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 x 4\n   Angebot Bedeutung     n  prop\n   <chr>       <dbl> <int> <dbl>\n 1 A               1     5   7.5\n 2 A               2    15  22.4\n 3 A               3    12  17.9\n 4 A               4    15  22.4\n 5 A               5    14  20.9\n 6 A               6     6   9  \n 7 B               1    11  13.9\n 8 B               2    12  15.2\n 9 B               3    18  22.8\n10 B               4    22  27.8\n11 B               5     8  10.1\n12 B               6     8  10.1\n```\n:::\n:::\n\n\n:::\n\nVorteilhaft ist auch, dass das Ergebnis der Funktion `freq_table()` ein Datenrahmen ist. Dadurch können weitere Datenrahmen-Operationen verkettet werden. Im @exm-kontingenztabelle-mehrfach2 werden die relativen Werte in einer Kreuztabelle so gegenübergestellt, dass die unterschiedliche Bewertung der Bedeutung für die beiden Angebote leichter verglichen werden können.\n\n::: {#exm-kontingenztabelle-mehrfach2}\n## Kontingenztabelle für zwei Merkmale als Kreuztabelle\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstichprobe |>\n    freq_table(Angebot, Bedeutung) |>\n    select(-n) |>\n    pivot_wider(names_from = Angebot, values_from = prop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n  Bedeutung     A     B\n      <dbl> <dbl> <dbl>\n1         1   7.5  13.9\n2         2  22.4  15.2\n3         3  17.9  22.8\n4         4  22.4  27.8\n5         5  20.9  10.1\n6         6   9    10.1\n```\n:::\n:::\n\n\n::: ",
    "supporting": [
      "kapitel_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}