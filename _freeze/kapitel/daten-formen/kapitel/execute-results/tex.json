{
  "hash": "f05bf3cdd1827b1da34883e3c1d670e7",
  "result": {
    "markdown": "---\nabstract: \"\"\n---\n\n\n\n# Daten formen {#sec-chapter-daten-formen}\n\n::: {.callout-warning}\n## Work in Progress\n:::\n\n\n\n\n\n\n\nDie Funktionen zum Formen von Datenrahmen werden durch die `tidyverse`-Bibliothek `tidyr` bereitgestellt. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n-- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\nv dplyr     1.1.2     v readr     2.1.4\nv forcats   1.0.0     v stringr   1.5.0\nv ggplot2   3.4.2     v tibble    3.2.1\nv lubridate 1.9.2     v tidyr     1.3.0\nv purrr     1.0.1     \n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\ni Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\n\n## Transponieren\n\nBeim Transponieren von Datenrahmen werden die Spalten und Zeilen von Merkmalen neu ausgerichtet. \n\nDas Transponieren von Datenrahmen ist keine vollständige Operation, sondern unterliegt je nach Ausgangsorientierung unterschiedlichen Anforderungen.\n\nDie Funktion `pivot_longer()` überführt Vektoren von der Matrixform (Breitform) in die Vektorform (Langform). Alle der transponierten Vektoren müssen dafür vom **gleichen Datentyp** sein. Beim Transponieren in die Vektorform werden immer zwei Vektoren erzeugt: \n\n- Der Wertevektor, der die Werte der ursprünglichen Vektoren aufnimmt und \n- Der Namenvektor für die ursprünglichen Vektorennamen.\n\nFalls keine anderen Angaben gemacht werden, heisst der Wertevektor `value` und der Namenvektor `name`. \n\n::: {.callout-note}\n## Merke\nDer Namenvektor ist gleichzeitig ein **Sekundärindex**.\n:::\n\nFall nicht alle Vektoren transponiert werden, dann werden die nicht transponierten Teile der Datensätze auf alle Datensätze der transponierten Vektoren erweitert. \n\n::: {.callout-note}\n## Merke\n\nEin Primärindex wird nach dem Transponieren zum Sekundärindex.\n:::\n\n::: {#exm-pivot_longer}\n## Transponieren in die Vektorform\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ursprünglich Daten\n(schweizerStaedte = \n    read_csv(\"geschlechter_schweizer_staedte.csv\") |>\n    select(-c(S, N)))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 10 Columns: 8\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (1): Ort\ndbl (7): Gesamt, S_M, S_F, N_M, N_F, S, N\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 6\n   Ort         Gesamt    S_M    S_F   N_M   N_F\n   <chr>        <dbl>  <dbl>  <dbl> <dbl> <dbl>\n 1 Winterthur  118681  57832  59074   817   958\n 2 Zürich      435319 214943 212778  3858  3740\n 3 Biel/Bienne  55600  27243  27827   232   298\n 4 Bern        137529  65215  69291  1580  1443\n 5 Luzern       85840  40576  43264   837  1163\n 6 Basel       178270  84896  88656  2586  2132\n 7 St. Gallen   78109  38303  38628   529   649\n 8 Lugano       63796  30116  32348   548   784\n 9 Lausanne    145524  68516  72902  2119  1987\n10 Genève      207630  97990 105850  1496  2294\n```\n:::\n\n```{.r .cell-code}\n# Transponieren in die Vektorform\n(schweizerStaedte |>\n    pivot_longer(- c(Ort, Gesamt)) ->\n        schweizerStaedteLang)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 40 x 4\n   Ort         Gesamt name   value\n   <chr>        <dbl> <chr>  <dbl>\n 1 Winterthur  118681 S_M    57832\n 2 Winterthur  118681 S_F    59074\n 3 Winterthur  118681 N_M      817\n 4 Winterthur  118681 N_F      958\n 5 Zürich      435319 S_M   214943\n 6 Zürich      435319 S_F   212778\n 7 Zürich      435319 N_M     3858\n 8 Zürich      435319 N_F     3740\n 9 Biel/Bienne  55600 S_M    27243\n10 Biel/Bienne  55600 S_F    27827\n# i 30 more rows\n```\n:::\n:::\n\n\n:::\n\nDie Funktion `pivot_wider()` transponiert einen Datenrahmen von der Vektorform (Langform) in die Matrixform (Breitform). Damit diese Operation durchführbar ist, muss neben dem Wertevektor ein Sekundärindex für die Vektorennamen **und** ein Sekundärindex für die *zeilenweise Zuordnung* der Werte vorliegen. Dieser Index wird von R verwendet, um die Vektorennamen zu erzeugen: Die Operation erzeugt für jeden diskreten Wert im Sekundärindex einen Vektor für die Matrixform. Der zweite Sekundärindex wird nach dem Transponieren zum Primärindex. \n\n::: {#exm-pivot_wider}\n## Transponieren in die Matrixform\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Daten transponieren\nschweizerStaedteLang |> \n    select(-Gesamt) |>\n    pivot_wider(names_from = Ort)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 11\n  name  Winterthur Zürich `Biel/Bienne`  Bern Luzern Basel `St. Gallen` Lugano\n  <chr>      <dbl>  <dbl>         <dbl> <dbl>  <dbl> <dbl>        <dbl>  <dbl>\n1 S_M        57832 214943         27243 65215  40576 84896        38303  30116\n2 S_F        59074 212778         27827 69291  43264 88656        38628  32348\n3 N_M          817   3858           232  1580    837  2586          529    548\n4 N_F          958   3740           298  1443   1163  2132          649    784\n# i 2 more variables: Lausanne <dbl>, Genève <dbl>\n```\n:::\n:::\n\n\n:::\n\nExistieren weitere Vektoren im Datenrahmen, dann werden diese beim Transponieren zusammengefasst, so dass die Werte nach dem Transponieren nur noch einmal im Ergebnis erscheinen.\n\n::: {.callout-warning}\n## Achtung\n\nExistiert kein zweiter Sekundärindex beim Transponieren in die Breitform, dann fasst R alle Datensätze zusammen, bei denen alle Werte in den zusätzlichen Vektoren gleich sind. Dieses Verhalten **kann** dazuführen, dass mehr Werte transponiert werden müssen als Zieldatensätze erzeugt werden können. In solchen Fällen werden die überzähligen Werte als Listenvektor abgelegt (@exm-bad-pivot_wider). Dieses Verhalten ist normalerweise *unerwünscht*. \n:::\n\n::: {#exm-bad-pivot_wider}\n## Transponieren mehrdeutiger Werte in die Matrixform\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ursprüngliche Daten einlesen\n(abDaten = read_csv2(\"data_ab_semi.csv\")) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\ni Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 136 Columns: 4\n-- Column specification --------------------------------------------------------\nDelimiter: \";\"\nchr (1): Angebot\ndbl (3): Punkte, Interesse, Bedeutung\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 136 x 4\n   Punkte Angebot Interesse Bedeutung\n    <dbl> <chr>       <dbl>     <dbl>\n 1   207. B               5         5\n 2   101. A               2         3\n 3   312. A               5         5\n 4   242. B               3         2\n 5   256. A               2         2\n 6   188. B               6         2\n 7   343. B               3         6\n 8   202. A               5         5\n 9   175. A               3         3\n10   213. B               3         2\n# i 126 more rows\n```\n:::\n\n```{.r .cell-code}\n# Daten transponieren\nabDaten |> \n    pivot_wider(names_from = Angebot, values_from = Punkte)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Values from `Punkte` are not uniquely identified; output will contain\nlist-cols.\n* Use `values_fn = list` to suppress this warning.\n* Use `values_fn = {summary_fun}` to summarise duplicates.\n* Use the following dplyr code to identify duplicates.\n  {data} %>%\n  dplyr::group_by(Interesse, Bedeutung, Angebot) %>%\n  dplyr::summarise(n = dplyr::n(), .groups = \"drop\") %>%\n  dplyr::filter(n > 1L)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 31 x 4\n   Interesse Bedeutung B         A        \n       <dbl>     <dbl> <list>    <list>   \n 1         5         5 <dbl [4]> <dbl [4]>\n 2         2         3 <dbl [4]> <dbl [4]>\n 3         3         2 <dbl [6]> <dbl [2]>\n 4         2         2 <dbl [1]> <dbl [6]>\n 5         6         2 <dbl [2]> <NULL>   \n 6         3         6 <dbl [4]> <dbl [3]>\n 7         3         3 <dbl [8]> <dbl [2]>\n 8         2         4 <dbl [2]> <dbl [2]>\n 9         4         2 <dbl [2]> <dbl [2]>\n10         5         6 <dbl [1]> <dbl [1]>\n# i 21 more rows\n```\n:::\n:::\n\n\n:::\n\n### Rezept: Operationen zusammenfassen\n\n#### Problem\n\nEs sollen mehrere Vektoren eines Datenrahmens auf die gleiche Art transformiert oder aggregiert werden. \n\n#### Lösung\n\nDie Vektoren werden zuerst in die Vektorform (Langform) *transponiert*. Anschliessend wird eine (gruppierte) Transformation oder gruppierte Aggregation durchgeführt.\n\n::: {#exm-pivot_longer-aggregate}\n## Zusammengefasstes Aggregieren\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschweizerStaedte |> \n    pivot_longer(-c(Ort, Gesamt)) |>\n    group_by(Ort, Gesamt) |>\n    summarise(\n        sum(value)\n    )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'Ort'. You can override using the `.groups`\nargument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 3\n# Groups:   Ort [10]\n   Ort         Gesamt `sum(value)`\n   <chr>        <dbl>        <dbl>\n 1 Basel       178270       178270\n 2 Bern        137529       137529\n 3 Biel/Bienne  55600        55600\n 4 Genève      207630       207630\n 5 Lausanne    145524       145524\n 6 Lugano       63796        63796\n 7 Luzern       85840        85840\n 8 St. Gallen   78109        78109\n 9 Winterthur  118681       118681\n10 Zürich      435319       435319\n```\n:::\n:::\n\n\n:::\n\n#### Erklärung\n\nDurch das transponieren entstehen ein Namenvektor und ein Wertevektor, wobei der Namenvektor auch als Sekundärindex behandelt werden kann. Sich wiederholende Operationen lassen sich so in einer gruppierten Operation zusammenfassen. Durch das Transponieren lässt sich die Code-Komplexität reduzieren, wodurch die Lösung insgesamt weniger fehleranfällig wird. \n\nDiese Logik lässt sich auf alle Datenoperationen anwenden. Im @exm-pivot_longer-mutate werden die Anteile am Gesamtvolumen von vier Merkmalen berechnet. Ohne das Transponieren würden repetitive Codeteile entstehen (@exm-no-pivot_longer-mutate). Die sich wiederholenden Codeteile entfallen durch das Transponieren und können in einer Operation behandelt werden. \n\n::: {#exm-no-pivot_longer-mutate}\n## Bestimmung des Anteils mehrerer Merkmale ohne Transponieren\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschweizerStaedte |> \n    mutate(\n        Anteil_S_M = S_M / Gesamt,\n        Anteil_S_F = S_F / Gesamt, \n        Anteil_N_M = N_M / Gesamt,\n        Anteil_N_F = N_F / Gesamt\n    ) |>\n    select(c(Ort, starts_with(\"Anteil\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 5\n   Ort         Anteil_S_M Anteil_S_F Anteil_N_M Anteil_N_F\n   <chr>            <dbl>      <dbl>      <dbl>      <dbl>\n 1 Winterthur       0.487      0.498    0.00688    0.00807\n 2 Zürich           0.494      0.489    0.00886    0.00859\n 3 Biel/Bienne      0.490      0.500    0.00417    0.00536\n 4 Bern             0.474      0.504    0.0115     0.0105 \n 5 Luzern           0.473      0.504    0.00975    0.0135 \n 6 Basel            0.476      0.497    0.0145     0.0120 \n 7 St. Gallen       0.490      0.495    0.00677    0.00831\n 8 Lugano           0.472      0.507    0.00859    0.0123 \n 9 Lausanne         0.471      0.501    0.0146     0.0137 \n10 Genève           0.472      0.510    0.00721    0.0110 \n```\n:::\n:::\n\n\n:::\n\n\n::: {#exm-pivot_longer-mutate}\n## Bestimmung des Anteils mehrerer Merkmale\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschweizerStaedte |> \n    pivot_longer(- c(Ort, Gesamt)) |>\n    mutate(\n        value = value / Gesamt\n    ) |>\n    # Anpassen des Ergebnisses zur Präsentation\n    select(- Gesamt) |>\n    pivot_wider(names_prefix = \"Anteil_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 5\n   Ort         Anteil_S_M Anteil_S_F Anteil_N_M Anteil_N_F\n   <chr>            <dbl>      <dbl>      <dbl>      <dbl>\n 1 Winterthur       0.487      0.498    0.00688    0.00807\n 2 Zürich           0.494      0.489    0.00886    0.00859\n 3 Biel/Bienne      0.490      0.500    0.00417    0.00536\n 4 Bern             0.474      0.504    0.0115     0.0105 \n 5 Luzern           0.473      0.504    0.00975    0.0135 \n 6 Basel            0.476      0.497    0.0145     0.0120 \n 7 St. Gallen       0.490      0.495    0.00677    0.00831\n 8 Lugano           0.472      0.507    0.00859    0.0123 \n 9 Lausanne         0.471      0.501    0.0146     0.0137 \n10 Genève           0.472      0.510    0.00721    0.0110 \n```\n:::\n:::\n\n\n:::\n\n\n### Rezept: Gruppiertes Zählen schöner präsentieren\n\n#### Problem\n\nBeim gruppierten Zählen werden die Sekundärindizes und die Ergebnisse nebeneinander dargestellt, so dass sich die Ergebnisse nur schwer vergleichen lassen. \n\n#### Lösung\n\nNach dem gruppierten Zählen wird das Ergebnis in die Matrixform transponiert.\n\n::: {#exm-gruppiertes-zaehlen-pivot}\n## Lesbarere Präsentation des gruppierten Zählen\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten = read_csv2(\"data_ab_semi.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ni Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 136 Columns: 4\n-- Column specification --------------------------------------------------------\nDelimiter: \";\"\nchr (1): Angebot\ndbl (3): Punkte, Interesse, Bedeutung\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\ndaten |>\n    count(Angebot, Interesse) |>\n    pivot_wider(\n        names_from = Angebot, \n        values_from = n, \n        values_fill = 0\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 x 3\n  Interesse     A     B\n      <dbl> <int> <int>\n1         1     3     2\n2         2    13    11\n3         3    13    25\n4         4    17    22\n5         5     9    10\n6         6     4     6\n7         7     0     1\n```\n:::\n:::\n\n\n:::\n\n#### Erklärung\n\nWerden beim Zählen über einen Datenrahmen mehrere Sekundärindizes verwendet, ist das Ergebnis nur schwer interpretierbar. Damit das Ergebnis für Menschen leichter zu lesen ist, muss die spaltenweise Darstellung in ein eleganteres Format überführt werden. Mit der Funktion `pivot_wider()` lassen sich die Daten in eine Kreuztabelle überführen. Das Ergebnis ähnelt nach dem Transponieren dem Ergebnis der `table()`-Funktion. Auf diese Weise lassen sich Häufungen in den Werten leichter erkennen. \n\nIn der Lösung werden drei besondere Parameter eingesetzt: \n\n1. Der Parameter `names_from` zeigt an, aus welchem Index die neuen Vektornamen  erzeugt werden sollen. \n2. Der Parameter `values_from` zeigt an, in welchem Vektor die zu transponierenden Werte stehen. \n3. der Parameter `values_fill` kommt zur Anwendung, wenn für eine Position kein Wert bereitsteht. Für die Zählung bedeutet das, dass nichts gezählt wurde. Deshalb wurde der Wert im Beispiel auf den Wert `0` gesetzt.\n\n## Hierarchisieren \n\nBeim Hierarchisieren werden ausgewählte Vektoren eines Datenrahmens entlang eines Sekundärinzes zu separaten Datenrahmen organisiert und in den ursprünglichen Datenrahmen eingebettet. Über solche eingebettete Datenrahmen lassen sich hierarchische Datenstrukturen erzeugen, die beispielsweise in einem JSON- oder YAML-Dokument (s. @sec-chapter-daten-importieren) gespeichert werden können. In R übernimmt diese Aufgabe die Funktion `nest()`.\n\nWeil R jedoch keine Vektoren mit Datenrahmen erlaubt, müssen diese Datenrahmen zusätzlich in eine Liste geschachtelt werden. Diese Liste dient nur zur Ablage in einem Vektor und besteht immer nur aus einem Element, nämlich dem eingebetteten Datenrahmen.\n\nMit der Funktion `unnest()` lassen sich eingebettete Datenrahmen wieder ausbetten. Diese Operation funktioniert jedoch nur dann zuverlässig, wenn alle eingebetteten Datenrahmen einheitliche Vektoren haben. Ist diese Bedingung nicht gegeben, dann erzeugt R zusätzliche Vektoren mit `NA` für alle Datensätze, die die Vektoren ursprünglich nicht enthielten. Die Funktion `unnest()` führt mehrere Spaltenkonkatenationen aus und ähnelt damit im Ergebnis der Funktion `bind_rows()`.\n\nDie beiden Funktionen `nest()` und `unnest()` sind speziell zur Erzeugung bzw. zum Auflösen von eingebetteten Datenrahmen gedacht. Gelegentlich enthält ein Datenrahmen einen Vektor mit einfachen Listen oder benannten Listen. Solche Vektoren sind vom Typ `list` und sollten mit den Funktionn `unnest_longer()` für einfache Listen sowie `unnest_wider()` für einheitlich benannte Listen [@wickham_tidyr_2023]. \n\n## Transponieren mit Zeichenketten\n\nEin spezieller Fall ist gegeben, wenn die Daten in Zeichenketten kodiert sind. Streng genommen handelt es sich hierbei nicht um eine Transponierenoperation, sondern um eine normale Transformation. Die entsprechenden Funktionen für diese Operation wurden aber nach dem gleichen Prinzip wie beim Hierarchisieren bzw. beim Transponieren angepasst.\n\nWie beim Transponieren kann ein Vektor in die Lang- oder die Breitform getrennt werden. Für die meisten Anwendungen eignen sich zwei Funktionen: \n\n- `separate_longer_delim()`\n- `separate_wider_delim()`\n\nGelegentlich sind die Daten in einer Zeichenkette nicht über ein eindeutiges Trennzeichen, sondern über ein Trennmuster kodiert. In diesem Fall kann das Trennmuster als *regulärer Ausdruck* der Funktion `separate_longer_regex()` bzw. `separate_wider_regex()` übergeben werden.\n\nFür festkodierte Werte stehen die beiden Funktionen `separate_longer_position()` und `separate_wider_position()` zur Verfügung. Diese Funktionen erwarten einen Vektor mit den Feldbreiten, um die Werte trennen zu können. \n\nDie Umkehrfunktion für alle `separate_`-Funktionen ist die Funktion `unite()`, mit der sich die Werte aus einer Lang- oder Breitform zu einem Zeichenkettevektor verketten lassen.\n",
    "supporting": [
      "kapitel_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}