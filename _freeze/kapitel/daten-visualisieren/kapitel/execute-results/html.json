{
  "hash": "ad3260c119c35c03762790c7c1f97dfa",
  "result": {
    "markdown": "---\n# bibliography: references.bib\n\nabstract: \"\"\n\nexecute: \n  echo: true\n---\n\n# Daten visualisieren {#sec-chapter-daten-visualisieren}\n\n\n\n\n\nIn R erstellen wir Plots mit Hilfe der `ggplot2`-Funktionen. Anders als in Excel werden mit diesen Funktionen Plots schrittweise aufgebaut und können auf diese Weise einheitlich reproduziert werden. \n\nAls Erstes laden wir wie immer die `tidyverse`-Bibliothek, damit wir die ggplot-Funktionen und die Funktionsverkettung verwenden können.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\n<!-- \nEine umfassende Einführung zu den Funktionen und Konzepten von `ggplot2` gibt das Buch von [Wickham (2021)](https://ggplot2-book.org/). Dieses Buch erläutert alle relevanten Konzepte und Tricks für die gängigsten Visualisierungen. \n-->\n\nWir erzeugen eine Datenvisualisierung immer mit den folgenden Funktionsaufrufen:\n\n1. Wir initiieren einen Plot mit der Angabe der darzustellenden Vektoren.\n2. Anschliessend wählen wir die Darstellung der Datenpunkte mit einer *Geometriefunktion* aus. \n\n::: {.callout-warning}\n## Achtung\n`ggplot2` verwendet zur Funktionsverkettung den `+`-Operator und nicht wie der Rest der modernen R-Funktionen den Verkettungsoperator `|>`. Wir können also leicht erkennen, dass ein Code-Fragment einen Plot erzeugt, wenn Funktionen mit `+` verkettet sind.\n:::\n\nMit den folgenden Funktionsaufrufen erzeugen wir ein einfaches Punktdiagramm. Als Beispielstichprobe verwenden wir hier die `iris`-Daten, die mit R mitgeliefert werden. \n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |>\n   ggplot(aes(x = Sepal.Length, y = Petal.Length)) + \n       geom_point()\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n## Technischer Aufbau von Visualisierungen\n\nIn der ersten Zeile legen wir fest, welche Daten visualisiert werden sollen. Die Grundlage für jede Datenvisualisierung ist immer ein Transformationsergebnis.\n\nIn der zweiten Zeile signalisieren wir R mit der Funktion `ggplot()`, dass wir einen Plot erzeugen wollen. Wir übergeben als Parameter das Ergebnis der `aes()`-Funktion. \n\n::: {.callout-note}\nDie Funktion `aes()` legt die ***ästhetischen*** Voraussetzungen für einen Plot fest. Damit legen wir fest, welche Daten für unsere Datenpunkte verwendet werden sollen.\n:::\n\nIn diesem Beispiel legen wir den Vektor `Sepal.Length` für die Koordinaten auf der x-Achse und `Petal.Length` für die Koordinaten auf der y-Achse fest. Die Datenpunkte werden also durch die beiden gemeinsam auftretenden Werte in diesen Vektoren festgelegt.\n\nMit der dritten Zeile legen wir die ***Geometrie*** der Datenpunkte fest. Alle `ggplot2`-Funktionsnamen zur Darstellung von Datenpunkten beginnen mit `geom_` (für Geometrie). In diesem Beispiel wollen wir unsere Datenpunkte mit Punkten (engl. Points) darstellen. Deshalb verwenden wir die Funktion `geom_point()`.\n\nDiese drei Schritte zeigen die grundsätzliche Logik zum Erstellen von Plots mit R.  \n\n## Mathematische Funktionen visualisieren {#sec-visualisation-math-func}\n\nIn der Mathematik werden regelmässig Funktionen besprochen. Diese Funktionen können wir mit R leicht visualisieren.\n\nDabei nutzen wir aus, dass wir in R neue Funktionen mit dem Schlüsselwort `function` definieren können. Im folgenden Beispiel verwenden wir die beiden Funktionen.\n\n$$\nf1(x) \\to x^2 - 3x\n$$\n\nund \n\n$$\nf2(x) \\to 4x + 2\n$$\n\n\nIm nächsten Schritt erstellen wir unsere beiden mathematischen Funktionen. Dabei beachten wir, dass wir den Namen der jeweiligen Funktion als eine Variable zuweisen müssen. Die rechte Seite der Zuweisung zeigt R an, dass wir eine neue Funktion mit dem Parameter `x` erstellen möchten. Nach dieser *Funktionsdefinition* folgt der sog. Funktionskörper in geschweiften Klammern. Hier schreiben wir die Formel unserer Funktion in der ausführlichen Operatorenschreibweise. Anders als bei der mathematischen Schreibweise dürfen wir keine Operatoren weglassen. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 = function (x) {\n    x ^ 2 - 3 * x\n}\n\nf2 = function (x) {\n    4 * x + 2\n}\n```\n:::\n\n\nDamit `ggplot` \"weiss\", welches Intervall für `x` wir darstellen möchten, erzeugen wir eine Stichprobe mit einem Vektor `x`, der genau zwei Werte hat. Diesen Vektor weisen wir der Variable `Darstellungsbereich` zu. Wenn wir die Werte symmetrisch angeben, dann landet die 0 auf der x-Achse in der Mitte unseres Diagramms. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDarstellungsbereich = tibble(x = c(-9, 9)) \n```\n:::\n\n\nJetzt können wir unsere Funktion visualisieren. Wir übergeben die Stichprobe im der Variablen `Darstellungsbereich` an die `ggplot()`-Funktion und legen mit dem Aufruf der `aes()`-Funktion mit dem Vektor `x` die Grenzen für die x-Achse fest. Anschliessend rufen wir die Funktion `geom_line()` auf, um einen Graphen zu erzeugen. Weil wir keine Werte für die y-Achse haben, legen wir fest, dass wir die y-Werte aus einer Funktion berechnen wollen. Das erreichen wir mit dem Parameter `stat = \"function\"`. Sobald wir diesen Parameter angeben, erwartet die `geom_line()` Funktion eine Funktion zur Berechnung der y-Werte. Diese Funktion übergeben wir mit dem Parameter `fun = f1`, wobei `f1` eine unserer vorab definierten Funktionen ist. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDarstellungsbereich |>\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f1)\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nDiesen Schritt können wir für die Funktion `f2` wiederholen. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDarstellungsbereich |>\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f2)\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nWeil wir mit `ggplot` Darstellungen überlagern können, dürfen wir die beiden Funktionen selbstverständlich auch in einem Diagramm darstellen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDarstellungsbereich |>\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f1) + \n        geom_line(stat = \"function\", fun = f2)\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nWir wollen die beiden Graphen noch visuell hervorheben, damit wir wissen, welcher Graph zu welcher Funktion gehört. Dabei überlassen wir die Auswahl der Farben `ggplot`, womit wir sicherstellen, dass die Farben nicht zu ähnlich sind. Dazu verwenden wir den Trick, dass wir jeder Geometrie-Funktion ergänzende ästhetische Parameter übergeben dürfen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDarstellungsbereich |>\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f1, \n                  aes(colour = \"f1(x) = x ^ 2 - 3 * x\")) + \n        geom_line(stat = \"function\", fun = f2, \n                  aes(colour = \"f2(x) = 4 * x + 2\"))\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nDie Legende für unser Diagramm hat keine schöne Überschrift. Das passen wir noch schnell mit der `labs()`-Funktion(für *labels* bzw. *Beschriftungen*) an. Dort geben wir für den ästhetischen Parameter die richtige Beschriftung an. In unserem Fall ist das `colour`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDarstellungsbereich |>\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", fun = f1, \n                  aes(colour = \"f1(x) = x ^ 2 - 3 * x\")) + \n        geom_line(stat = \"function\", fun = f2, \n                  aes(colour = \"f2(x) = 4 * x + 2\")) +\n        labs(colour = \"Funktion\")\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## Berechnete Visualisierungen\n\nWir haben im Abschnitt zu einfachen Visualisieren in R die Funktion  `ggplot()` kennengelernt, um zwei Vektoren zu visualisieren.\n\nSehr häufig wir einen Vektor und wollen sehen, wie die Werte in diesem Vektor verteilt sind. Wir sollen also die Werte in dem Vektor für die Visualisierung **aggregieren**. Hierbei handelt es sich um eine so häufige Aufgabe, dass uns `ggplot()` diese Aufgabe abnimmt. \n\nFür verschiedene Visualisierungen hat `ggplot()` vordefinierte Funktionen, mit denen Werte für die Visualisierung aufbereitet werden, wenn die Werte für eine Achse fehlen. Diese Funktionen müssen wir im Detail nicht kennen, denn `ggplot()` wählt diese automatisch für uns aus. \n\nWir lernen heute zwei wichtige berechnete Visualisierungen kennen. \n\n1. Das Histogramm \n2. Den Box-Plot\n\n### Histogramm\n\n::: {#def-histogramm}\nAlso **Histogramm** werden Balkendiagramme bezeichnet, die die *Häufigkeiten* von gemessenen Werte darstellen. \n:::\n\nDas übliche Balkendiagramm erzeugen wir mit der Funktion `geom_bar()`. Diese Funktion verwenden wir immer, wenn unsere gemessenen Werte nur auf bestimmte Werte fallen (können). Die `geom_bar()`-Funktion zählt für jeden gemessenen Wert die Anzahl der Datensätze, in denen dieser Wert vorkommt. \n\nGelegentlich sind unserer Werte so verteilt, dass nur selten zwei oder mehr Datensätze gleiche Werte haben. In solchen Fällen verwenden wir die Funktion `geom_histogram()`. Diese Funktion teilt den gesamten Wertebereich in gleichmässige Intervalle und zählt die Anzahl der Datensätze im jeweiligen Intervall.\n\nDas folgende Beispiel veranschaulicht die Situation. \n\nWir verwenden die Stichprobe `digitales_umfeld1.csv`. In dieser Stichprobe gibt es den Vektor `tage`, der das Alter der beantwortenden Person in Tagen festhält. Dabei handelt es sich rein formell um *diskrete Werte*. Wenn wir die Verteilung dieser Werte in einem Histogramm für *diskrete Werte* darstellen würden, dann erhalten wir das folgende Histogramm: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigitales_umfeld = read_delim(\"befragung_digitales_umfeld/digitales_umfeld1.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 135 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): mobilgeraet\ndbl (4): alter, tage, monate, digitalisiert\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\ndigitales_umfeld |> \n    ggplot(aes(x = tage)) +\n        geom_bar()\n```\n\n::: {.cell-output-display}\n![Tage-Histogram Diskrete Werte](kapitel_files/figure-html/fig-tage-barplot-1.png){#fig-tage-barplot width=672}\n:::\n:::\n\n\nAuf diesem Histogramm kann man keine Verteilung erkennen. Es scheint, als ob alle Werte genau einmal vorkommen. Der Wertebereich der y-Achse deutet aber darauf hin, dass einzelne Werte bis zu drei Mal vorkommen. Diese Balken sind jedoch so dünn, dass sie nicht im Diagramm dargestellt werden können. \n\nDie Werte in diesem Vektore verhalten sich also wie *kontinuierliche Werte*. Deshalb verwenden wir die Funktion `geom_histogram()`, um die Daten darzustellen. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigitales_umfeld |> \n    ggplot(aes(x = tage)) +\n        geom_histogram()\n```\n\n::: {.cell-output-display}\n![Tage-Histogram](kapitel_files/figure-html/fig-tage-histo-1.png){#fig-tage-histo width=672}\n:::\n:::\n\n\nAus diesem Histogramm können wir wesentlich besser die Verteilung des Alters in Tagen ablesen, weil der Wertebereich in grössere Segmente gegliedert wurde und die Datensätze in diesen Segmenten gezählt wurden.\n\n::: {.callout-note}\n## Merke \nHistogramme für *kontinuierliche Werte* erzeugen wir mit der Funktion `geom_histogram()`. Histogramme für *diskrete Werte*  erzeugen wir mit der `geom_bar()`-Funktion.\n:::\n\n#### Histogramme selbst berechnen\n\nGelegentlich haben uns bereits die Häufigkeiten für ein Histogramm als Teil unserer Stichproben. In solchen Fällen verwenden wir die Funktion `geom_col()`, um die Daten als Histogramm darzustellen. In diesem Fall müssen wir neben der x-Achse auch den Vektor mit den berechneten Werten für die y-Achse an `ggplot()`'s `aes()`-Funktion übergeben.\n\n### Box-Plot\n\n::: {#def-boxplot}\nEin Box-Plot stellt die Verteilung eines Stichprobenvektors mit Hilfe von Quartilen dar. \n:::\n\nBox-Plots werden mit der `geom_boxplot()` Funktion dargestellt. \n\nBeim Box-Plot wird der Median als dicke Linie dargestellt. Der Interquartilsabstand wird als Rechteck (*Box*) um den Median visualisiert (2. und 3. Quartil). Dabei liegt die Hälfte der aller gemessenen Werte innerhalb der dargestelltn Box.  Der gesamte Umfang wird durch Linien links (1. Quartil) und rechts (4. Quartil) vom Interquartilsabstand dargestellt. Manchmal werden Punkte an den äusseren Rändern  dargestellt. Diese Punkte stellen sog. Ausreisser dar.\n\nWiederholen wir die Visualisierung für unsere Alterstage mit einem Boxplot, dann erhalten wir folgendes Ergebnis: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigitales_umfeld |> \n    ggplot(aes(x = tage)) +\n        geom_boxplot()\n```\n\n::: {.cell-output-display}\n![Tage-Boxplot](kapitel_files/figure-html/fig-tage-boxplot-1.png){#fig-tage-boxplot width=672}\n:::\n:::\n\n\nWir erkennen jetzt leicht, dass der Grossteil der Gruppe unter 10000 Tagen alt ist und dass es sechs Ausreisser gibt, die deutlich älter als der Grossteil der Gruppe sind. \n\n### Punkt- und Jitter-Diagramme\n\n\n\nDie dritte wichtige visuelle Analysetechnik sind Punktwolken. Bei Punktwolken stellen wir die Werte von zwei Vektoren ähnlich einer Kreuztabelle gegenüber und überprüfen das gemeinsame Auftreten von Werten in den Vektoren unserer Messungen.\n\nFür Punktwolken stehen zwei Funktionen zur Verfügung: \n\n1. `geom_point()` für kontinuierliche Werte.\n2. `geom_jitter()` für diskrete Werte.\n\nMit Punktdiagrammen werden zwei Merkmale mit kontinuierlichen Daten gegenübergestellt. Punktdiagramme bilden **Beziehungen zwischen Merkmalen** ab. \n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |>\n    ggplot(aes(x = Sepal.Length, y = Sepal.Width)) +\n        geom_point()\n```\n\n::: {.cell-output-display}\n![Punktdiagramm der `iris`-Daten](kapitel_files/figure-html/fig-iris-points-1.png){#fig-iris-points width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten = read_delim(\"befragung_digitales_umfeld/befragung.csv\");\n\ndaten |>\n    filter(q18_6 > 0 & \n           q18_7  > 0 ) |>\n    ggplot(aes(x = q18_6 , \n               y = q18_7)) + \n        geom_point()\n```\n\n::: {.cell-output-display}\n![Beispiel eines Punktdiagramms mit diskreten Daten](kapitel_files/figure-html/fig-attitude-point-1.png){#fig-attitude-point width=672}\n:::\n:::\n\n    \nIn diesem Beispiel sehen wir, dass alle Werte genau an den gleichen Punkten im Koordinatensystem liegen. Ein solcher Plot ist ein gutes Beispiel für *diskrete Werte*. Bei diskreten Werten fallen alle Messungen genau auf bestimmte Punkte im Wertebereich. Kontinuierliche Werte weichen oft ein wenig voneinander ab, sodass wir eine Wolke sehen würden. \n\nUm Punktwolken für diskrete Werte zu erzeugen, verwenden wir die `geom_jitter()`-Funktion. Diese Funktion erzeugt einen kleinen Bereich um den diskreten (echten) Messwert und verteilt die einzelnen Datensätze mit einem zufälligen Abstand vom echten Messwert. Dadurch wird das gemeinsame Auftreten von Werten deutlich sichtbar, sofern es Gemeinsamkeiten gibt.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten |>\n    filter(q18_6 > 0 & \n           q18_7  > 0 ) |>\n    ggplot(aes(x = q18_6 , \n               y = q18_7)) + \n        geom_jitter()\n```\n\n::: {.cell-output-display}\n![Beispiel eines Jitter-Diagramms](kapitel_files/figure-html/fig-attitude-jitter-1.png){#fig-attitude-jitter width=672}\n:::\n:::\n\n\nDurch den leichten Versatz sind nun gehäufte Wertepaare leichter zu erkennen. Bei Jitter-Plots dürfen wir aber nie vergessen, dass die Punkte zwar Messungen repräsentieren, aber leicht vom echten Messpunkt versetzt dargestellt wurden.\n\n### Ausgleichsgeraden\n\nIm vorigen Abschnitt können wir eine Häufung entlang der nach rechts aufsteigenden Diagonalen erkennen. Solche Häufungen in Punktwolken deuten auf *Korrelationen* hin. \n\n::: {#def-korrelation}\nEine **Korrelation** bezeichnet das wiederholte Auftreten von Wertepaaren in Stichproben. Korrelationen deuten auf Zusammenhänge zwischen zwei Vektoren hin.\n:::\n\nÄhnlich wie beim Vergleichen mit Histogrammen ist es bei Punktwolken hilfreich, für die Wolke eine Referenz zur Orientierung zu haben. Das erreichen wir mit der `geom_smooth()`-Funktion. Die Methode `lm` steht für \"lineares Modell\". In diesem Modell versteckt sich das Wort Linie und deshalb *erzeugt ein lineares Modell immer eine Ausgleichsgerade*. Der graue Bereich zeigt uns die Spanne des Fehlerbereichs für diese Gerade. Bei einer linearen Korrelation sollte diese Gerade den Häufungen in unserem Plot ungefähr folgen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten |>\n    filter(q18_6 > 0 & \n           q18_7  > 0 ) |>\n    ggplot(aes(x = q18_6 , \n               y = q18_7)) + \n        geom_jitter() +\n        geom_smooth(method=lm)\n```\n\n::: {.cell-output-display}\n![Beispiel eines Jitter-Diagramms mit Ausgleichsgerade](kapitel_files/figure-html/fig-attitude-jitter-smooth-1.png){#fig-attitude-jitter-smooth width=672}\n:::\n:::\n\n\nDas folgende Beispiel zeigt eine Punktwolke, bei der die Wertepaare zufällig über den gesamten Wertebereich gestreut sind. In diesem Fall ist eine Korrelation kaum wahrscheinlich. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten |>\n    filter(q18_3 > 0 & \n           q18_29  > 0 ) |>\n    ggplot(aes(x = q18_3 , \n               y = q18_29)) + \n        geom_jitter() +\n        geom_smooth(method=\"lm\")\n```\n\n::: {.cell-output-display}\n![Beispiel eines Jitter-Diagramms mit flacher Ausgleichsgerade](kapitel_files/figure-html/fig-attitude-jitter-smooth2-1.png){#fig-attitude-jitter-smooth2 width=672}\n:::\n:::\n\n\n    \nIm Beispiel ist die Ausgleichsgerade fast waagerecht. Wenn eine Ausgleichsgerade fast waagerecht ist, dann liegt in der Regel auch keine *Korrelation* vor.\n\nEs gibt auch nicht-lineare Korrelationen. In diesem Fall sehen wir Häufungen in bestimmten Teilen unserer Punktwolken oder unsere Punkte folgen einer Kurve. Solche Korrelationen müssten einer entsprechenden \"Ausgleichskurve\" folgen. Eine solche Ausgleichskurve erzeugen wir mit `loess` als Ausgleichsmethode. \n\nWenn eine Ausgleichskurve fast gerade ist, dann sollten wir eine lineare Korrelation annehmen. Ein Beispiel für eine fast gerade Ausgleichskurve zeigt uns der nächste Plot. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten |>\n    filter(q18_3 > 0 & \n           q18_29  > 0 ) |>\n    ggplot(aes(x = q18_3 , \n               y = q18_29)) + \n        geom_jitter() +\n        geom_smooth(method = \"loess\")\n```\n\n::: {.cell-output-display}\n![Beispiel eines Jitter-Diagramms mit nicht linearer Ausgleichslinie](kapitel_files/figure-html/fig-attitude-jitter-smooth-loess-1.png){#fig-attitude-jitter-smooth-loess width=672}\n:::\n:::\n\n\n## Mehrdimensionale Plots mit `aes`\n\n### Farbkodierung\n\nMit der Farbkodierung können zusätzliche Merkmale in einer Visualisierung kodiert werden. ggplot unterscheidet für die Farbkodierung zwischen diskreten und kontinuierlichen Daten. Bei diskreten Daten verwendet R Farben, die sich gut voneinander unterscheiden lassen. Bei kontinuierlichen Daten werden Farbverläufe zwischen mehreren Farben verwendet. Ausserdem hängt die Färbung von der Art der Visualisierung ab. Flächige Darstellungselemente, wie die Balken von Balkendiagrammen, wird eine *Füllfarbe* gesetzt. Die Füllfarbe wird über die Ästhetik `fill` kontrolliert. Darstellungselemente wie Linien oder Punkte wird eine *Linienfarbe* gesetzt. Die Linienfarbe wird über die Ästhetik `colour` festgelegt.\n\n::: {.callout-note}\n## Merke\nDie Färbung von Punkten wird über die Linienfarbe gesteuert.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |>\n    ggplot(aes( x = Sepal.Length, \n                y = Sepal.Width, \n                colour = Species)) + # <1>\n        geom_point()\n```\n\n::: {.cell-output-display}\n![Punktdiagramm der `iris`-Daten mit farblich hervorgehobenen Spezieswerten](kapitel_files/figure-html/fig-iris-points-color-1.png){#fig-iris-points-color width=672}\n:::\n:::\n\n\n1. Farbliche Hervorhebung\n\nBalkendiagramme und Histogramme benötigen eine Flächenfärbung.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |>\n    ggplot(aes( x = Sepal.Length, \n                fill = Species)) + # <1>\n        geom_histogram()\n```\n\n::: {.cell-output-display}\n![Histogramm der `iris`-Daten mit farblich hervorgehobenen Spezieswerten](kapitel_files/figure-html/fig-iris-histo-color-1.png){#fig-iris-histo-color width=672}\n:::\n:::\n\n\n1. Farbliche Hervorhebung\n\n::: {.callout-tip}\n## Praxis\nWenn Histogramme oder Balkendiagramme eine zusätzliche farbliche Kodierung erhalten, verbirgt eine gestapelte Balkendarstellung die Verteilungen. Mit dem Parameter `position` lässt sich die Positionierung der Balken steuern. Dies wird beispielsweise durch die Funktion `position_dodge()` vereinfacht. \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |>\n    ggplot(aes( x = Sepal.Length, \n                fill = Species)) + # <1>\n        geom_histogram(position = position_dodge()) # <2>\n```\n\n::: {.cell-output-display}\n![Histogramm der `iris`-Daten mit farblich hervorgehobenen Spezieswerten](kapitel_files/figure-html/fig-iris-histo-color-dodge-1.png){#fig-iris-histo-color-dodge width=672}\n:::\n:::\n\n\n1. Farbliche Hervorhebung\n2. Positionierung der hervorgehobenen Balken\n\nDie Ästhetik kann auch in den Geometriefunktionen angepasst werden. Wird hier für die Farbästhetik jeweils ein einzelner Wert angegeben, erzeugt `ggplot()` einen Vektor mit diskreten Werten und weist die Farben dynamisch zu. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDarstellungsbereich |>\n    ggplot(aes(x)) + \n        geom_line(stat = \"function\", \n                  fun = f1, \n                  aes(colour = \"f1(x) = x ^ 2 - 3 * x\")) +  # <1>\n        geom_line(stat = \"function\", \n                  fun = f2, \n                  aes(colour = \"f2(x) = 4 * x + 2\")) +      # <2>\n        labs(colour = \"Funktion\")\n```\n\n::: {.cell-output-display}\n![Angepasste Ästhetik mit Einzelwerten in Geometriefunktionen](kapitel_files/figure-html/fig-mfunc-line-colored-1.png){#fig-mfunc-line-colored width=672}\n:::\n:::\n\n\n1. Farbliche Hervorhebung der ersten Funktion\n2. Farbliche Hervorhebung der zweiten Funktion\n\n::: {.callout-warning}\n`ggplot` unterstützt Farbcodes zur Konfiguration von Füll- und Linienfarben ausserhalb der normalen Ästhetikparameter. Mit diesen Farbcodes wird die normale Füll- oder Linienfarbe auf ***eine*** andere Farbe geändert. Diese Methode zur Anpassung von Farbe sollte **vermieden** werden, weil für solche Farben keine Legende erzeugt wird. \n:::\n\n### Grössenkodierung\n\n::: {.callout-note}\n## Merke\nDie Grössenkodierung eignet sich am Besten für *kontinuierliche Daten*.\n:::\n\n::: {.callout-note}\n## Merke\nDie Grössenkodierung lässt sich auf Linien oder Punkte anwenden. Flächen lassen sich nicht zusätzlich grössenkodieren, weil sie bereits Werte über die Grösse kodieren.\n:::\n\nDie Grössenkodierung von Punkten erfolgt über die Ästhetik `size`. Auf diese Weise werden **Bubble-Charts** (Blasendiagramme) erstellt.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(\"geschlechter_schweizer_staedte.csv\") -> \n    geschlechteranteile_ch\n\ngeschlechteranteile_ch |>\n    ggplot(aes(x = S, y = N, size = Gesamt)) + \n        geom_point() +\n        xlab(\"Männeranteil der ständigen Wohnbevölkerung\") +\n        ylab(\"Manneranteil der nicht-ständigen Wohnbevölkerung\")\n```\n\n::: {.cell-output-display}\n![Grössenkodierung am Beispiel des Männeranteils in Schweizer Städten](kapitel_files/figure-html/fig-coding-points-size-1.png){#fig-coding-points-size width=672}\n:::\n:::\n\n\nDie Grössenkodierung von Linien erfolgt über die Ästhetik `linewidth`. Die Linienbreite funktioniert analog zur Punktgrösse im Punktdiagramm. \n\n::: {.callout-note}\n## Merke\nDie Ästhetik `size` wird in Kombination mit `geom_point()`, `geom_text()` oder `geom_label()` verwendet.\n\nDie Ästhetik `linewidth` wird in Kombination mit `geom_line()` verwendet.\n:::\n\n### Formkodierung\n\nDie Formkodierung kodiert die Werte einer Variable über die Form (engl. `shape`). \n\n::: {.callout-note}\n## Merke\nDie Formkodierung eignet sich nur für *diskrete Daten*!\n:::\n\n::: {.callout-note}\n## Merke\nDie Formkodierung kann nur ein Punkt- oder Jitter-Diagramm ergänzen. \n:::\n\nDie Formkodierung erfolgt über die Ästhetik `shape`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n    mutate(am = am |> factor()) |>\n    ggplot(aes(\n        x = mpg, \n        y = hp, \n        shape = am # <1>\n    )) + \n    geom_point()\n```\n\n::: {.cell-output-display}\n![Anwendung von `facet_wrap()`](kapitel_files/figure-html/fig-coding-points-shape-1.png){#fig-coding-points-shape width=672}\n:::\n:::\n\n\n1.  Formkodierung über das Merkmal `am`.\n\nEine Variante der Formkodierung ist die Linienart. Die Kodierung der Linienart erfolgt äber die Ästhetik `linetype`. Diese Formatierung prinzipiell mit allen Diagrammentypen verwendet werden, die Linien darstellen. Für Boxplots oder Balkendiagramme sollte eine Kodierung über die Linienart vermieden werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |>\n    ggplot(aes(x = Sepal.Length, \n               y = Sepal.Width, \n               linetype = Species)) +\n        geom_point() +\n        geom_smooth(method = \"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![Kodierung über Linienarten](kapitel_files/figure-html/fig-linetrype-1.png){#fig-linetrype width=672}\n:::\n:::\n\n\nEine weitere Variante der Formkodierung sind Textmarkierungen. Textmarkierungen werden über die Ästhetik `label` zugewiesen. Für eine Textmarkierung wird der Wert des gewählten Merkmals im Diagramm angezeigt.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeschlechteranteile_ch |>\n    ggplot(aes(x = S, y = N, label = Ort)) +\n        geom_text() +\n        xlab(\"Männeranteil der ständigen Wohnbevölkerung\") +\n        ylab(\"Manneranteil der nicht-ständigen Wohnbevölkerung\")\n```\n\n::: {.cell-output-display}\n![Textmarkierungen über den Männeranteil an der ständigen und nicht-ständigen Wohnbevölkerung Schweizer Städte](kapitel_files/figure-html/fig-textlabel-1.png){#fig-textlabel width=672}\n:::\n:::\n\n\n\n### Facetted Plots\n\nEin **Facetted Plot** gliedern die Darstellung von Werten in mehrere Teildiagramme. Diese Teildiagramme enthalten in der Regel nur die Werte \n\n::: {.callout-note}\n## Merke\nFacetten können nur mit *diskreten Daten* erstellt werden!\n:::\n\nFacetten sind **keine** Ästhetik, sondern eine Steuerung. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n    ggplot(aes(mpg, hp)) + \n    geom_point() +\n    facet_wrap(~ gear) # <1>\n```\n\n::: {.cell-output-display}\n![Anwendung von `facet_wrap()`](kapitel_files/figure-html/fig-visual-facets-1.png){#fig-visual-facets width=672}\n:::\n:::\n\n\n1. Facetten folgen den Werten des Merkmals `gear`.\n\nEine Variante von `facet_wrap()` ist `facet_grid()`. Diese Funktion erstellt eine visuelle Matrix entlang der Werte zweier diskreter Merkmale. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n    ggplot(aes(mpg, hp)) + \n    geom_point() +\n    facet_grid(carb ~ gear) # <1>\n```\n\n::: {.cell-output-display}\n![Anwendung von `facet_grid()`](kapitel_files/figure-html/fig-visual-facet-grid-1.png){#fig-visual-facet-grid width=672}\n:::\n:::\n\n\n1. Facetten über die Werte der Merkmale `gear` (horizontal) und `carb` (vertikal).\n\n## Spezielle Visualisierungen\n\n### Donut-Diagramme\n\n::: {.callout-important} \nTortendiagramme und Donut-Diagramme werden oft falsch interpretiert, weil Kreisflächen schwerer verglichen werden können als die Höhen von Balken. Sie sollten nur zur Illustration, aber nie zur Argumentation verwendet werden.\n:::\n\nR kann auch Plots erstellen, die nur einen Datenvektor umfassen. In diesem Fall wird der zweite Vektor für die y-Achse aus den Werten des Vektors berechnet. Diese Möglichkeit haben wir schon bei der Erstellung von Histogrammen kennengelernt. \n\nNehmen wir das folgende Beispiel: Wir erstellen ein Stichprobenobjekt mit einem Vektor `q00_demo_gen`, der die Werte `1 : Keine Angabe`, `2 : Weiblich` und `3 : Männlich` enthält.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten2 = tibble(\n    q00_demo_gen = c(\"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"2 : Weiblich\", \"1 : Keine Angabe\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \"2 : Weiblich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \"3 : Männlich\", \n\"2 : Weiblich\", \"3 : Männlich\", \"2 : Weiblich\", \"3 : Männlich\", \n\"2 : Weiblich\")\n)\n```\n:::\n\n\nUns interessiert nun: ***Wie oft kommen die drei möglichen Werte in unserer Stichprobe vor?*** \n\nWir können die Werte mit `count()` selbst berechnen oder `ggplot` die Arbeit überlassen. Anstelle der `geom_col()`-Funktion verwenden wir nun die `geom_bar()`-Funktion. `geom_bar()` erwartet einen Vektor für die x-Achse und berechnet für die y-Achse das Auftreten der Werte, so wie wir es mit der `count()`-Funktion auch bestimmen würden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten2 |>\n    count(q00_demo_gen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  q00_demo_gen         n\n  <chr>            <int>\n1 1 : Keine Angabe     1\n2 2 : Weiblich        95\n3 3 : Männlich       104\n```\n:::\n\n```{.r .cell-code}\ndaten2 |>\n    ggplot(aes(x = q00_demo_gen)) +\n        geom_bar()\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n   \nMit diesem Plot können wir die Unterschiede in unserer Werteverteilung leichter erkennen. \n\nFür Präsentationen ist so ein Plot aber nicht wahnsinnig attraktiv. Färben wir den Plot also ein. Das machen wir, indem wir den Vektornamen auch  für die Füllung der Balken verwenden. `ggplot` wählt nun für jeden Wert in diesem Vektor eine eigene Farbe aus. Dadurch färben sich unsere Balken ein. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten2 |>\n    ggplot(aes(x=q00_demo_gen, fill = q00_demo_gen)) +\n        geom_bar()\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n    \n\nFür Histogramme verwenden wir normalerweise ein kartesisches Koordinatensystem. Wir können aber auch ein anderes Koordinatensystem wählen. Eine Variante sind **polare Koordinaten**. Mit einem polaren Koordinatensystem erreichen wir kreisförmige Darstellungen. Wir müssen dazu die Dimension, die auf das Zentrum des Diagramms zeigt, festlegen und als Parameter übergeben. In unserem Fall ist das die y-Dimension.\n\nWir stellen unsere Daten in einem polaren Koordinatensystem dar, indem wir mit der `coord_polar()`-Funktion ggplot mitteilen, dass wir ein anderes Koordinatensystem wünschen. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten2 |>\n    ggplot(aes(x=q00_demo_gen, fill = q00_demo_gen)) +\n        geom_bar() +\n        coord_polar(\"y\") \n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nUnser Plot hat jetzt unschöne Beschriftungen. Die werden wir mit einem Formatierungsthema los. `ggplot` hat verschiedenen Formatierungen als Thema vordefiniert. Eines davon ist das Thema `void`. Diese Formatierung entfernt alle Hintergründe, Achsen und Beschriftungen ausser Legenden.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten2 |>\n    ggplot(aes(x=q00_demo_gen, fill = q00_demo_gen)) +\n        geom_bar() +\n        coord_polar(\"y\") +\n        theme_void()\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\nDas sieht doch gleich viel besser aus.\n\n::: {.callout-note}\nSolche ringartigen Visualisierungen werden  als Zielscheiben- oder  **Donut-Diagramme** bezeichnet.\n:::\n\n### Torten-Diagramme\n\nFür Torten- bzw. Kreisdiagramme müssen alle Balken eines Balkendiagramms übereinander gestapelt werden. Das erreichen wir, indem wir für die x-Achse einen konstanten Wert angeben. Z.B. nehmen wir dazu die leere Zeichenkette. So werden merkwürdige Beschriftungen im Diagramm vermieden. Damit wir die Balken auseinanderhalten können, färben wir sie ein. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten2 |>\n    ggplot(aes(x =\"\", fill = q00_demo_gen)) +\n        geom_bar() \n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\nMit der Funktion `coord_flip` werden die Achsen vertauscht und das Diagramm gedreht.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten2 |>\n    ggplot(aes(x =\"\", fill = q00_demo_gen)) +\n        geom_bar() +\n        coord_flip()\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\nWir erkennen nun deutlich, dass `ggplot` immer versucht möglichst viel Fläche zu nutzen. \n\nDas Interessante an dieser Darstellung ist aber nicht dieses Format, sondern dass wir dieses Diagramm ebenfalls in einem polaren Koordinatensystem darstellen können. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaten2 |>\n    ggplot(aes(x =\"\", fill = q00_demo_gen)) +\n        geom_bar() +\n        coord_polar(\"y\") + \n        theme_void()\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\nAuf diese Weise erzeugen wir Tortendiagramme. \n",
    "supporting": [
      "kapitel_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}