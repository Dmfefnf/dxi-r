{
  "hash": "b4b6562914f1229da985bd08d816e298",
  "result": {
    "markdown": "---\nabstract: \"\"\n---\n\n\n\n# Matrix-Operationen {#sec-chapter-matrix-operationen}\n\n\n\n\n\n\n\nMatrizen sind in R 2-dimensionale *numerische* Vektoren, die aus Zeilen und Spalten bestehen. Die Anzahl der Zeilen und Spalten gibt die *Dimensionalität* der Matrix an. Allgemein wird von einer $m \\times n$-Matrix gesprochen, wobei $m$ für die Anzahl der Zeilen und $n$ für die Anzahl der Spalten steht. \n\n::: {.callout-note}\n## Merke\nBei Matrizen werden immer zuerst die Zeilen und dann die Spalten angegeben.\n:::\n\n## Matrizen erstellen\n\nEine Matrix wird in R mit der Funktion `matrix()` erstellt. Diese Funktion erwartet einen Vektor als erstes Argument. Zusätzlich muss mit `ncol` oder `nrow` angegeben werden, wie viele Spalten bzw. Zeilen die Matrix haben soll. Der optionale Paramter `byrow` zeigt an, ob die Werte zeilen- oder spaltenweise in die Matrix übernommen werden sollen. Die Zeilenschreibweise erleichtert die Eingabe einer Matrix (@exm-matrix-erstellen-komplett). \n\n::: {#exm-matrix-erstellen-komplett}\n# Matrix in Zeilenschreibweise erzeugen\n\n\n::: {.cell}\n\n```{.r .cell-code}\n( # Diese Klammer gibt das Ergebnis der Operation aus.\n    matrixA = matrix( \n    c( \n        1, 2, 3,\n        3, 2, 1\n    ), ncol = 3, nrow = 2, byrow = TRUE)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    3    2    1\n```\n:::\n:::\n\n\n::: \n\nIst die Länge des Eingabevektors grösser als die gewünschten Zeilen- oder Spaltenanzahl erlauben, dann werden alle überzähligen Werte verworfen (@exm-matrix-erstellen-überzählig) und eine Warnung erzeugt. \n\n::: {.callout-tip}\n## Praxis\nEs muss nur die Anzahl der Spalten oder der Zeilen beim Erzeugen einer Matrix angegeben werden. Der jeweils andere Wert wird aus der Länge und dem angegebenen Wert ermittelt. \n:::\n\n::: {#exm-matrix-erstellen-überzählig}\n## Matrix mit überlangem Eingabevektor erzeugen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix( \n    c( \n        1, 2, 3,\n        3, 2, 1,\n        4, 5, 6\n    ), ncol = 3, nrow = 2, byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in matrix(c(1, 2, 3, 3, 2, 1, 4, 5, 6), ncol = 3, nrow = 2, byrow =\nTRUE): Datenlänge [9] ist kein Teiler oder Vielfaches der Anzahl der Zeilen [2]\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    3    2    1\n```\n:::\n:::\n\n\n::: \n\nIst die Länge des Eingabevektors kürzer als für eine Matrix mit den gewünschten Dimensionen notwendig wäre, dann wird der Vektor wie bei einer Vektortransformation solange wiederholt, bis alle Positionen in der Matrix besetzt sind (@exm-matrix-erstellen-auffüllen). Ist der Vektor kein Vielfaches der Zeilen- oder der Spaltenzahl, dann werden alle überzähligen Werte mit einer entsprechenden Warnung verworfen. \n\n::: {#exm-matrix-erstellen-auffüllen}\n## Matrix durch Auffüllen des Eingabevektors erzeugen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix( \n    c( \n        1, 2, 3\n    ), ncol = 4, nrow = 3, byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    1\n[2,]    2    3    1    2\n[3,]    3    1    2    3\n```\n:::\n:::\n\n\n::: \n\n\n### Identitätsmatrix erzeugen\n\nDie Identitätsmatrix ist eine quadratische Diagonalmatrix, wobei an allen Positionen der Hauptdiagonalen der Wert `1` steht. Diese Matrix wird in R mit der Funktion `diag()` erzeugt (@exm-identitätsmatrix). \n\n::: {#exm-identitätsmatrix}\n## 5x5 Identitätsmatrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n```\n:::\n:::\n\n\n:::\n\n## Matrixdimensionen\n\nDie *Länge* einer Matrix entspricht der Anzahl der Positionen in der Matrix und kann wie bei Vektoren mit der Funktion `length()` ermittelt werden. Diese Information ist jedoch nicht sehr nützlich.\n\nDie Dimensionalität einer Matrix wird mit der Funktion `dim()` ausgegeben. Das Ergebnis dieser Funktion gibt einen Vektor der Länge `2` zurück. Das erste Element dieses Vektors enthält die Anzahl der Zeilen und das zweite Element enthält die Anzahl der Spalten der Matrix. \n\n::: {#exm-matrix-dimensions}\n## Matrixdimensionen mit `dim()` abfragen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA |> dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n:::\n\n\n:::\n\nDie beiden Werte können separat mit den beiden Funktionen `nrow()` und `ncol()` abgefragt werden.\n\n::: {#exm-matrix-dimensions-separate}\n## Matrixdimensionen mit `nrow()` und `ncol()` abfragen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA |> nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nmatrixA |> ncol()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n:::\n\n## Matrixwerte referenzieren\n\nDas Referenzieren von Werten einer Matrix erfolgt analog zum Referenzieren von Vektorwerten. Der Index eines Werts einer Matrix ist über die Zeilen und die Spalten definiert. \n\n::: {#exm-matrix-werte-referenzieren}\n## Matrixwerte referenzieren\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA[2,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n:::\n\nÜber diese Notation ist es möglich eine ganze Zeile oder eine ganze Spalte einer Matrix zu referenzieren.\n\n::: {#exm-matrix-spalte-referenzieren}\n## Matrixspalten und -zeilen referenzieren\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA[2,]  # Zeile 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 2 1\n```\n:::\n\n```{.r .cell-code}\nmatrixA[, 2] # Spalte 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 2\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-warning}\n## Achtung\n\nEine Matrix bleibt im Hintergrund eine Vektorstruktur. Wird der Separator zwischen den Zeilen- und Spaltenindex weggelassen und nur *ein* Index angegeben, dann behandelt R die Matrix als Vektor in der spaltenweisen Form. Die Reihenfolge der Werte kann mit der Funktion `as.vector()` angezeigt werden. Das gleiche gilt für die Verwendung der Konkatenation ohne das dimensionstrennende Komma.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA |> as.vector()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 2 2 3 1\n```\n:::\n\n```{.r .cell-code}\nmatrixA[2,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nmatrixA[c(2,3)] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 2\n```\n:::\n\n```{.r .cell-code}\nmatrixA[,c(2,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    2    3\n[2,]    2    1\n```\n:::\n:::\n\n\n::: \n\n### Zeilen- und Spaltenüberschriften\n\nDie Zeilen- und Spalten einer Matrix können in R mit Überschriften ***benannt*** werden. Das Benennen erfolgt über einen sog. Namensvektor. Diese Vektor muss die gleiche Länge haben, wie die Anzahl der zu benennenden Zeilen bzw. Spalten der Matrix, wobei die Zeilen und Spalten nicht gleichzeitig benannt werden können. \n\n::: {.callout-note}\n## Merke\nDie Zeilen- und Spaltennamen gehören nicht zu den Werten einer Matrix und werden in Operationen in der Regel nicht berücksichtigt.\n:::\n\n::: {#exm-zeilennamen-zuweisen}\n## Zeilennamen zuweisen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(matrixA) <- c(\"oben\", \"unten\")\ncolnames(matrixA) <- c(\"links\", \"mitte\", \"rechts\")\n\nmatrixA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      links mitte rechts\noben      1     2      3\nunten     3     2      1\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-tip}\n## Praxis\n\nGrundsätzlich kann auch die Funktionsverkettung beim Benennen der Zeilen oder Spalten einer Matrix verwendet werden. \n\n```r\nmatrixA |> rownames() <- c(\"oben\", \"unten\")\n```\n\nDiese Verwendung sollte allerdings vermieden werden, weil die Zuweisung und der Datenstrom in diesen Fällen gegenläufig wären. \n:::\n\nNachdem eine Zeile oder eine Spalte benannt wurde, werden die Namen in allen nachfolgenden Zugriffen immer in das Ergebnis aufgenommen. Ausserdem können die Namen zur Referenzierung der Werte verwendet werden (@exm-zeilennamen-referenzierung). \n\n::: {#exm-zeilennamen-referenzierung}\n## Zeilennamen zur Rerferenzierung verwenden\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA[\"oben\",]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n links  mitte rechts \n     1      2      3 \n```\n:::\n\n```{.r .cell-code}\nmatrixA[\"unten\", \"mitte\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n:::\n\nEs ist möglich einzelne Zeilen- oder Spaltennamen zuzuweisen oder zu ändern (@exm-zeilennamen-ändern).\n\n::: {#exm-zeilennamen-ändern}\n## Zeilennamen ändern\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(matrixA)[2] <- \"zentrum\"\n\nmatrixA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      links zentrum rechts\noben      1       2      3\nunten     3       2      1\n```\n:::\n:::\n\n\n:::\n\nDie Namen einer Matrix lassen sich entfernen, indem den Zeilen- oder Spaltennamen der Wert `NULL` zugewiesen wird. \n\n::: {#exm-zeilennamen-entfernen}\n## Zeilennamen entfernen\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(matrixA) <- NULL\ncolnames(matrixA) <- NULL\n\nmatrixA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    3    2    1\n```\n:::\n:::\n\n\n:::\n\n## Matrizen transponieren\n\nBeim Transponieren einer Matrix werden die Indizes für alle Werte vertauscht. Diese Operation übernimmt die R-Funktion `t()`.\n\n::: {#exm-matrix-transponieren}\n## Eine Matrix transponieren\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA |> t()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    2\n[3,]    3    1\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-note}\n## Merke\n\nBeim **Transponieren einer Matrix** werden die Spalten in Zeilen bzw. die Zeilen in Spalten umgewandelt.\n:::\n\n::: {.callout-tip}\nBeim Transponieren werden vorhandene Zeilen- und Spaltennamen mittransponiert.\n:::\n\n## Vektorform\n\nMatrizen kennen zwei Arten der Vektorform:\n\n- Die spaltenweise Vektorform, bei der die Spaltenvektoren einer Matrix zu einem  Vektor konkateniert werden. \n- Die zeilenweise Vektorform, bei der die Zeilenvektoren einer Matrix zu einem Vektor konkateniert werden. \n\nR speichert eine Matrix intern in ihrer spaltenweisen Vektorform. Die spaltenweise Vektorform kann also direkt über die Funktion `as.vector()` ermittelt werden. Das gleiche Ergebnis wird erzeugt, wenn die Matrix der Vektorkonkatenation `c()` als Argument übergeben wird (@exm-column-vectorform).\n\n::: {.callout-tip}\n## Praxis\n\nWeil bei der Verwendung der Funktion `c()` nicht leicht ersichtlich ist, dass die Vektorform ermittelt wird, sollte für diese Operation immer die Funktion  `as.vector()`  verwendet werden.\n:::\n\n::: {#exm-column-vectorform}\n## Spaltenweise Vektorform einer Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA |> as.vector()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 2 2 3 1\n```\n:::\n\n```{.r .cell-code}\nmatrixA |> c()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 2 2 3 1\n```\n:::\n:::\n\n\n:::\n\nBeim Umwandeln einer Matrix in ihre **zeilenweise Vektorform** wird in R ausgenutzt, dass diese Vektorform identisch mit der spaltenweisen Vektorform ihrer transponierten Matrix ist. Diese Gleichheit ergibt sich aus dem Transponieren, bei der Zeilen in Spalten umgewandelt werden (@exm-row-vectorform).\n\n::: {#exm-row-vectorform}\n## Zeilenweise Vektorform einer Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA |> t() |> as.vector()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 3 2 1\n```\n:::\n\n```{.r .cell-code}\nmatrixA |> t() |> c()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 3 2 1\n```\n:::\n:::\n\n\n:::\n\n## Skalar- und Vektortransformationen\n\nBei Skalartransformationen wird ein einzelner Wert mit jedem Wert in der Matrix verknüpft. \n\n::: {#exm-skalar-matrix-transformation}\n## Skalaraddition mit einer Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 * matrixA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2    4    6\n[2,]    6    4    2\n```\n:::\n:::\n\n\n:::\n\n\nDieses Prinzip lässt sich auf Vektoren und Matrizen verallgemeinern. Bei Vektoren muss der Vektor die gleiche Länge wie die Zeilen der Matrix haben. Der Vektor wird dann *spaltenweise* mit der Matrix verknüpft (@exm-vektor-matrix-transformation). \n\n::: {#exm-vektor-matrix-transformation}\n## Vektoraddition mit einer Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA + 1:2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    5    4    3\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-warning}\n## Achtung!\n\nHat der Vektor keine passende Länge, dann wird die Länge des Vektors durch Wiederholung an die Länge der Matrix angepasst. Die Transformation erfolgt in diesem Fall wie eine Vektortransformation, wobei die Zeilen- und Spaltenstruktur der Matrix erhalten bleibt (@exm-vektor-matrix-transformation-upscaling). \n:::\n\n::: {#exm-vektor-matrix-transformation-upscaling}\n## Vektoraddition mit einer Matrix und einem inkompatiblen Vektor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA + 1:3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2    5    5\n[2,]    5    3    4\n```\n:::\n:::\n\n\n:::\n\nFür die Transformation einer Matrix mit einer anderen Matrix mit R *müssen* beide Matrizen die gleiche Dimensionalität haben. Ist diese Voraussetzung gegeben, dann werden die Werte mit dem gleichen Index paarweise miteinander verknüpft (@exm-matrix-matrix-skalartransformation).\n\n::: {.callout-warning}\n## Achtung!\n\nWerden zwei Matrizen unterschiedlicher Dimensionalität verknüpft, dann erweitert R die kleinere der beiden Matrizen **nicht**! \n:::\n\n::: {#exm-matrix-matrix-skalartransformation}\n## Verknüpfung von zwei Matrizen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixB = matrix(c(1, 2, 2, 1, 1, 2), nrow = 2)\n\nmatrixA + matrixB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2    4    4\n[2,]    5    3    3\n```\n:::\n:::\n\n\n:::\n\n### Matrizen vergleichen\n\nUm die Gleichheit zwischen zwei Matrizen zu vergleichen, müssen zwei Bedingungen erfüllt sein:\n\n1. Die Länge der beiden Matrizen muss gleich sein.\n2. Die Dimensionalität der beiden Matrizen muss gleich sein.\n3. An allen Positionen müssen die Werte gleich sein. \n\nDiese Prüfung übernimmt in R die Funktion `all.equal()`. Damit diese Funktion in logischen Ausdrücken verwendet werden kann, muss der Wert an der ersten Position des Ergebnisvektors ausgewertet werden, weil diese Funktion alle Unterschiede zwischen zwei Matrizen zurückgibt (@exm-all-equal).\n\n::: {#exm-all-equal}\n## Zwei Matrizen vergleichen\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(matrixA, matrixB)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Attributes: < Length mismatch: comparison on first 1 components >\"\n[2] \"Mean relative difference: 0.5555556\"                              \n```\n:::\n\n```{.r .cell-code}\n# Für logische Ausdrücke\nall.equal(matrixA, matrixB)[1] == TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n:::\n\n## Kreuzprodukt\n\nDas Kreuzprodukt (oder Matrixmultiplikation) ist eine Erweiterung der bekannten Multiplikation für Matrizen. Beim Kreuzprodukt muss die linke Matrix genausoviele Spalten haben, wie Zeilenanzahl der rechten Matrix. Das Kreuzprodukt ist dann wie folgt definiert: \n\n$$\n\\begin{aligned}\nA \\times B &= \\begin{bmatrix} \na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\cdots & a_{mn} \\\\\n\\end{bmatrix} \n\\times\n\\begin{bmatrix} \nb_{11} & b_{12} & \\cdots & b_{1p} \\\\\nb_{21} & b_{22} & \\cdots & b_{2p} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nb_{n1} & b_{n2} & \\cdots & b_{np} \\\\\n\\end{bmatrix} \\\\\\\n\\\\\\\n&= \\begin{bmatrix} \n\\sum_{i=1}^{n}{a_{1i} \\cdot b_{i1}} & \\sum_{i=1}^{n}{a_{1i} \\cdot b_{i2}} & \\cdots & \\sum_{i=1}^{n}{a_{1i} \\cdot b_{ip}} \\\\\n\\sum_{i=1}^{n}{a_{2i} \\cdot b_{i1}} & \\sum_{i=1}^{n}{a_{2i} \\cdot b_{i2}} & \\cdots & \\sum_{i=1}^{n}{a_{2i} \\cdot b_{ip}} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\sum_{i=1}^{n}{a_{mi} \\cdot b_{i1}} & \\sum_{i=1}^{n}{a_{mi} \\cdot b_{i2}} & \\cdots & \\sum_{i=1}^{n}{a_{mi} \\cdot b_{ip}} \\\\\n\\end{bmatrix} \n\\end{aligned}\n$$\n\nIn R wird das Kreuzprodukt mit dem `%*%`-Operator durchgeführt.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    3    2    1\n```\n:::\n\n```{.r .cell-code}\n(matrixC = matrix(\n    c(3, 2, 2, 3, \n      1, 2, 3, 1, \n      1, 2, 1, 1), \n    ncol = 4, \n    byrow = TRUE)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    3    2    2    3\n[2,]    1    2    3    1\n[3,]    1    2    1    1\n```\n:::\n\n```{.r .cell-code}\nmatrixA %*% matrixC\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    8   12   11    8\n[2,]   12   12   13   12\n```\n:::\n:::\n\n\n\n::: {.callout-tip}\n## Praxis\n\nWerden mehrere Matrizen nacheinander multipliziert, so können bekannte Matrizen vorab miteinander multipliziert werden, wenn sie in der Berechnung direkt aufeinanderfolgen. \n:::\n\n### Zeilen- und Spaltensummen\n\nFür die Zeilensumme ist ein Spaltenvektor notwendig. Dieser Vektor ist ein Einsvektor mit der Länge von der Anzahl der **Matrixspalten**. Wegen der Regeln für das Kreuzprodukt muss der Einsvektor der rechte Operand des Kreuzprodukts sein (@exm-matrix-zeilensumme). \n\n::: {#exm-matrix-zeilensumme}\n## Zeilensumme\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrixA %*% rep(1, ncol(matrixA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    6\n[2,]    6\n```\n:::\n:::\n\n\n:::\n\nFür die Spaltensumme ist ein Zeilenvektor notwendig. Dieser Vektor ist ein Einsvektor mit der Länge von der Anzahl der **Matrixzeilen**. Weil R-Vektoren keine Orientierung haben, sondern immer als Spaltenvektoren behandelt werden, muss der Vektor noch transponiert werden. Bei der Zeilensumme ist ausserdem zu beachten, dass der Einsvektor der linke Operand des Kreuzprodukts sein muss (@exm-matrix-spaltensumme). \n\n::: {#exm-matrix-spaltensumme}\n## Zeilensumme\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(rep(1, nrow(matrixA))) %*% matrixA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4    4    4\n```\n:::\n:::\n\n\n:::\n\n## Äusseres Vektorprodukt\n\nDas äussere Vektorprodukt erlaubt es Matrizen aus den Werte von zwei Vektoren mit einem *beliebigen Operators* zu erzeugen. Im Gegensatz zum Kreuzprodukt ist die Orientierung der beiden Vektoren durch das äussere Produkt vorgegeben: Der zweite Vektor wird immer als Zeilenvektor angenommen. \n\nDer Operator des äusseren Produkts ist `%o%`, wobei als Verknüpfung die Multiplikation verwendet wird. Mit der Funktion `outer()` können beliebige Operatoren (d.h. Funktionen mit zwei Operatoren) angegeben werden.\n\n::: {#exm-outerprodukt}\n## Äusseres Produkt mit der Addition als Operator\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nouter(1:3, 0:5, `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    2    3    4    5    6\n[2,]    2    3    4    5    6    7\n[3,]    3    4    5    6    7    8\n```\n:::\n:::\n\n\n:::\n\nIn der Anwendung sind logische Ausdrücke als Operatoren für das äussere Produkt von besonderer Bedeutung. In R müssen alle logischen Ausdrücke, die nicht nur eine Vergleichsoperation umfassen, als Funktion der `outer()`-Funktion übergeben werden (s. @exm-vorgängersumme).\n\n::: {.callout-tip}\n## Praxis\n\nMit dem äusseren Produkt über logische Ausdrücle lassen sich beliebige Matrizenstrukturen aus Sequenzen erzeugen. \n:::\n\n### Dreieckmatrizen erzeugen\n\nDreiecksmatrizen werden in der Regel über das äussere Produkt zweier Sequenzen erzeugt. Es wird zwischen oberen und unteren Dreiecksmatrizen unterschieden. Bei einer oberen Dreiecksmatrix sind alle Positionen mit Zeilenindizes, welche kleiner als der jeweilige Spaltenindex sind, mit dem Wert `1` und alle anderen Position mit `0` belegt. Bei einer unteren Dreieckmatrix sind die Positionen mit dem Wert `1` belegt, an denen der Zeilenindex grösser als der Spaltenindex ist. Alternativ erzeugen die beiden Funktionen `upper.tri()` und `lower.tri()` die gewünschte Dreiecksmatrix aus einer existierenden Matrix.\n\n::: {#exm-triangle-matrix}\n## Erzeugen einer unteren Dreiecksmatrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 * outer(1:4, 1:4, `>=`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    1    1    0    0\n[3,]    1    1    1    0\n[4,]    1    1    1    1\n```\n:::\n\n```{.r .cell-code}\n# etwas expressiver\n1 * lower.tri(diag(4), diag = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    1    1    0    0\n[3,]    1    1    1    0\n[4,]    1    1    1    1\n```\n:::\n:::\n\n\n:::\n\n### Vorgänger- und Nachfolgersummen\n\nVorgänger- und Nachfolgersummen bilden die Summe aus aufeinanderfolgenden Werten eines Vektors. Diese Summe kann durch die Kombination einer Matrixmultiplikation mit dem äusseren Produkt errreicht werden. Für diese Summen wird eine Matrix benötigt, in welcher an allen zu summierenden Positionen der Wert `1` (das neutrale Element der Multiplikation) steht. \n\n@exm-vorgängersumme bestimmt die Summe vom Wert und den beiden Vorgängern einer bestimmten Position in einem Vektor. Die Subtraktion mit `2` zeigt an, wie viele Werte vor der aktuellen Position berücksichtigt werden sollen.\n\n::: {#exm-vorgängersumme}\n## Vorgängersumme für einen Vektor der Länge 10\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor = 1:10\nvektor %*% outer(\n    1:10, \n    1:10, \n    function (a, b) (b >= a & a >= b - 2)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]    1    3    6    9   12   15   18   21   24    27\n```\n:::\n:::\n\n\n::: \n\n## Co-Occurence Matrizen\n\nEine Co-Occurence Matrix oder **Kontingenztabelle** aus zwei Vektoren lässt sich am leichtesten mit der `table()`-Funktion erstellen. Diese Funktion zählt das gemeinsame Auftreten von Werten in zwei *gleichlangen* Vektoren von beliebigen Datentyp.\n\nDas Ergebnis ist eine *benannte Matrix*, wobei die Zeilen den Werten im ersten Vektor und die Spalten den Werten im zweiten Vektor entsprechen.\n\n::: {#exm-coocmatrix-table}\n## Kontingenztabelle für zwei Vektoren\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 = c(1, 2, 4, 3, 2, 1, 1, 2, 4)\nv2 = c(9, 8, 7, 7, 7, 8, 9, 9, 8)\n\n(ctable = table(v1, v2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   v2\nv1  7 8 9\n  1 0 1 2\n  2 1 1 1\n  3 1 0 0\n  4 1 1 0\n```\n:::\n\n```{.r .cell-code}\nctable[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2 3 4 \n1 1 0 1 \n```\n:::\n\n```{.r .cell-code}\nctable[3,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7 8 9 \n1 0 0 \n```\n:::\n:::\n\n\n:::\n\n## Determinanten\n\nDie Determinante einer **quadratischen Matrix** $A$ wird mit der `det()`-Funktion ermittelt. \n\n::: {#exm-matrix-determinant}\n## Determinante einer Matrix bestimmen\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Eine quadratische Matrix aus matrixA erzeugen\n(matrixQ = matrixA %*% t(matrixA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   14   10\n[2,]   10   14\n```\n:::\n\n```{.r .cell-code}\ndet(matrixQ)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 96\n```\n:::\n:::\n\n\n:::\n\n## Eigenwerte\n\nDie Eigenwerte $\\lambda$ und Eigenvektoren einer **quadratischen Matrix** $A$ werden mit der Funktion `eigen()` bestimmt. Diese Funktion gibt eine benannte Liste zurück. Unter `values` finden sich die Eigenwerte der Matrix und unter `vectors` sind die Eigenvektoren als *Spaltenvektoren* gespeichert.\n\n::: {#exm-matrix-eigenvalues}\n## Eigenwerte und Eigenvektoren einer Matrix bestimmen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasisQ = eigen(matrixQ)\n\nbasisQ[[\"values\"]] # oder basisQ$values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 24  4\n```\n:::\n\n```{.r .cell-code}\nbasisQ[[\"vectors\"]] # oder basisQ$vectors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          [,1]       [,2]\n[1,] 0.7071068 -0.7071068\n[2,] 0.7071068  0.7071068\n```\n:::\n:::\n\n\n:::\n\n## Inversematrix\n\nDie Inverse $A^{-1}$ einer **quadratischen Matrix** $A$ wird in R mit der Funktion `solve()` bestimmt (@exm-inverse-matrix).\n\n::: {#exm-inverse-matrix}\n## Inverse Matrix berechnen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolve(matrixQ)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]       [,2]\n[1,]  0.1458333 -0.1041667\n[2,] -0.1041667  0.1458333\n```\n:::\n:::\n\n\n:::\n\n## `Matrix`-Bibliothek {#sec-matrix-bibliothek}\n\nDas Kreuzprodukt, das äussere Produkt und das Transponieren werden durch R automatisch bereitgestellt. Für komplexere Aufgaben oder sehr grossere Matrizen dient die Bibliothek `Matrix` [@bates_r_2023]. Diese Bibliothek gehört zur R-Standardinstallation und ist auf jedem System vorhanden. Die Bibliothek stellt alle relevanten Funktionen für Matrix-Operationen, die für mathematische Matrix-Operationen benötigt werden. \n\nDiese Bibliothek sollte immer geladen werden, wenn sehr grosse Matrizen oder Matrizen mit vielen `0`-Werten verwendet werden. Besonders für den zweiten Fall ist die sog. **Sparse Matrix** (deutsch \"dünnbesetzte Matrix\") von besonderer Bedeutung. Eine dünnbesetzte Matrix ist eine Matrix mit vielen `0`-Werten, wobei *viel* \"mehr als ein Drittel der Positionen\" bedeutet. In solchen Matrizen lässt R die `0`-Werte weg, so dass diese Werte keinen Speicher benötigen und keine Berechnungen für die entsprechenden Operationen (insbesondere beim Kreuzprodukt) durchgeführt werden. Abgesehen von dieser speziellen Behandlung der `0`-Werte unterscheiden sich dünnbesetzte Matrizen in R nicht von anderen Matrizen.\n\n::: {#exm-sparsematrix-erzeugen}\n## Dünnbesetzte Matrix erzeugen \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Matrix)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttache Paket: 'Matrix'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nDie folgenden Objekte sind maskiert von 'package:tidyr':\n\n    expand, pack, unpack\n```\n:::\n\n```{.r .cell-code}\nMatrix( matrix(c(0, 1, 0, 0, 0, 1, 2, 0, 0), ncol = 3), sparse = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3 x 3 sparse Matrix of class \"dgCMatrix\"\n          \n[1,] . . 2\n[2,] 1 . .\n[3,] . 1 .\n```\n:::\n:::\n\n\n:::\n\nDie `Matrix`-Bibloiothek stellt ausserdem viele Hilfreiche Funktionen für die Arbeit mit Matrizen bereit. Dazu gehören beispielsweise die Funktionen `colSums()` und `rowSums()`, mit denen die Spalten- bzw. die Zeilensummen berechnet werden. @exm-matrix-spaltensumme und @exm-matrix-zeilensumme lassen sich so vereinfachen (@exm-matrix-spaltensumme-colsums).\n\n::: {#exm-matrix-spaltensumme-colsums}\n## Zeilen- und Spaltensumme mit der `Matrix`-Bibliothek\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(matrixA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 4 4\n```\n:::\n\n```{.r .cell-code}\nrowSums(matrixA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6 6\n```\n:::\n:::\n\n\n:::\n\nDie Bibliothek stellt ausserdem mit der `band()`-Funktion eine komfortable Methode für diagonale Band-Matrizen bereit. Eine Bandmatrix heisst eine quadratische Matrix, die ein diagonales Werteband enthält. Mit dieser Funktion lassen sich Band-Matrize für gleitende Summen (@exm-vorgängersumme) leichter erzeugen (@exm-bandmatrix)\n\n::: {#exm-bandmatrix}\n## Vorgängersumme mit der `band()`-\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nband(Matrix(1, 10, 10, sparse = TRUE), 0, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10 x 10 sparse Matrix of class \"dtCMatrix\"\n                         \n [1,] 1 1 1 . . . . . . .\n [2,] . 1 1 1 . . . . . .\n [3,] . . 1 1 1 . . . . .\n [4,] . . . 1 1 1 . . . .\n [5,] . . . . 1 1 1 . . .\n [6,] . . . . . 1 1 1 . .\n [7,] . . . . . . 1 1 1 .\n [8,] . . . . . . . 1 1 1\n [9,] . . . . . . . . 1 1\n[10,] . . . . . . . . . 1\n```\n:::\n\n```{.r .cell-code}\nvektor %*% band(Matrix(1, 10, 10, sparse = TRUE), 0, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 x 10 Matrix of class \"dgeMatrix\"\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]    1    3    6    9   12   15   18   21   24    27\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "kapitel_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}