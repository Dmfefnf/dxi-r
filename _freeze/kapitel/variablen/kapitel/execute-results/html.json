{
  "hash": "abc5fa52a3cbdf0628fa8d488783fc93",
  "result": {
    "markdown": "---\nabstract: \"\"\n\nexecute: \n  echo: true\n---\n\n# Variablen, Funktionen und Operatoren {#sec-chapter-variablen}\n\n## Variablen\n\nVariablen sind spezielle R Symbole (s. @sec-chapter-language) mit denen Werte für die spätere Verwendung markiert werden. Variablen sind also **Bezeichner**, welche die eigentlichen Werte **substituieren**. \n\nDamit eine Variable einen Wert substituieren kann, muss der Wert der Variablen *zugewiesen* werden. Ein Wert kann dabei ein einzelner Wert eines fundamentalen Datentyps oder eine komplexe Datenstruktur sein. \n\nBei der ersten Zuweisung wird eine Variable *deklariert* (@def-deklaration).\n\n::: {#exm-var-zuweisen}\n## Den Wert 1 der Variable `var1` zuweisen\n```r\nvar1 = 1\n```\n:::\n\nVariablen müssen in einem Geltungsbereich *eindeutig* sein. Wird nämlich einer Variable mehrfach zugewiesen, dann ist der Wert einer Variablen der Wert der letzten Zuweisung.\n\nDer **Geltungsbereich** (engl. Scope) einer Variablen wird durch Funktionskörper definiert. R kennt dabei drei Arten von Geltungsbereichen. In diesem Zusammenhang spricht man von äusseren (engl. *outer scope*) und inneren Geltungsbereichen (engl. *inner scope*).\n\nGrundsätzlich können alle Variablen in einem Geltungsbereich verwendet werden, die in einem der äusseren Geltungsbereiche deklariert und zugewiesen wurden. Variablen der inneren Geltungsbereiche sind in den äusseren Geltungsbereichen *nicht verfügbar*. \n\nDer **globale Geltungsbereich** gilt für alle Variablen, die ausserhalb einer Funktion oder einer Bibliothek erzeugt werden.\n\nDer **Funktionsgeltungsbereich** ist auf den Funktionsköper einer Funktion beschränkt. \n\nDer **Modulgeltungsbereich** ist der globale Geltungsbereich einer Funktionsbibliothek. Variablen dieses Geltungsbereichs sind im globalen Geltungsbereich eines R-Scripts nicht erreichbar. In der Praxis spielt dieser Geltungsbereich eine untergeordnete Rolle\n\n::: {.callout-warning}\nDie letzte Zuweisung ist nicht zwingend die Zuweisung, die als letztes im Code erscheint.\n:::\n\n## Funktionen\n\nIn R bilden Funktionen die Grundlage für die Datenverarbeitung. Fast alle Spracheelemente sind als Funktionen umgesetzt.\n\n### Identätsfunktion\n\nR hat eine explizite Identitätsfunktion `identity()`. Diese Funktion setzt die Identität für einen Parameter um. Die Funktion wird zur allgemeinen Identitätsfunktion, indem die Parameterliste als Liste übergeben.\n\n::: {#exm-mehrparametrische-identität}\n## Mehrparametrische Indentität\n\n::: {.cell}\n\n```{.r .cell-code}\nidentity(list(1, \"Daten und Information\", TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"Daten und Information\"\n\n[[3]]\n[1] TRUE\n```\n:::\n:::\n\n:::\n\n### Transformationen\n\nTransformationen verändern die Werte eines Vektors, wobei das Ergebnis *immer* ein Ergebnis der Länge des ursprünglichen Vektors hat. \n\nIn R sind alle arithmetischen Operatoren Transformatoren (s. @exm-arithm-transformation)\n\n::: {#exm-arithm-transformation}\n## Additive Transformation eines Zahlenvektors (Skalarprodukt)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 9 , 7, 3, 5) * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2 18 14  6 10\n```\n:::\n:::\n\n:::\n\nEine besondere Gruppe innerhalb der Transformationen sind die Matrizen-Produkte (@sec-chapter-matrix-operationen) sowie das Umformen von Vektoren (@sec-chapter-daten-formen). Diese Transformationen erzeugen aus mehreren Vektoren *Vektorfelder*, wobei die urspünglichen Werte erhalten bleiben bzw. durch eine Multiplikation umgeformt werden.\n\n### Aggregatoren\n\nAggregationen fassen Werte eines Vektors zusammen. Das Ergebnis von Aggregatoren ist oft ein einzelner Wert, kann aber auch mehrere Werte umfassen. In solchen Fällen hat das Aggregat höchstens die Länge des Eingabevektors.\n\nTypische Aggregationen sind die Summe (`sum()`, @exm-aggregation-sum) und andere statistische Kennzahlen (@sec-chapter-daten-beschreiben).\n\n::: {#exm-aggregation-sum}\n## Summenaggregation\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3, 4) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n::: \n\n### Genratoren\n\nGeneratoren bilden eine besondere Funktionsgruppe in R. Mit ihnen lassen sich Werte erzeugen. In dieser Gruppe gibt es zwei Arten:\n\n1. Sequenzgeneratoren\n1. Zufallsgeneratoren\n\n#### Sequenzgeneratoren\n\nSequenzgeneratoren erzeugen Sequenzen von Werten. Sequenzgeneratoren werden in R zur systematischen Erzeugung von Vektoren verwendet. \n\nDie beiden wichtigsten Funktionen dieser Gruppe sind die Funktionen `seq()` und `rep()`. \n\nDie Funktion `seq()` erzeugt eine Sequenz von Werten mit fester Schrittweite. In R wird eine Sequenz über einen Startwert sowie die Länge, die Schrittweite *oder* den Endwert definiert.\n\n::: {#exm-sequenz}\n## Sequenzen mit `seq()` erzeugen\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(5) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nseq(2, 5) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nseq(2, len = 5) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 5 6\n```\n:::\n\n```{.r .cell-code}\nseq(2, len = 3, by = 2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6\n```\n:::\n:::\n\n::: \n\nSequenzen mit der Schrittweite `0` wiederholen den Startwert für die erforderliche Länge. Solche Sequenzen werden relativ häufig verwendet, weshalb @exm-sequenz-rep etwas umständlich ist. \n\n::: {#exm-sequenz-rep}\n## Einsvektor der Länge 4 mit `seq()` erzeugen\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, len = 4, by = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 1 1\n```\n:::\n:::\n\n::: \n\nDiese Operation kann mit R vereinfacht werden. Hierfür diehnt die Funktion `rep()` (für *replicate*). Die Funktion `rep()` erfordert den Wiederholungswert sowie die Anzahl der Wiederholungen (@exm-replicate).\n\n::: {#exm-replicate}\n## Einsvektor der Länge 4 mit `rep()` erzeugen\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(1, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 1 1\n```\n:::\n:::\n\n::: \n\n#### Zufallsgeneratoren\n\n::: {#def-zufallszahlen}\n**Zufallszahlen** sind numerische Werte, die zufällig ausgewählt werden. \n:::\n\nZufallszahlen werden in normalen Computer-Programmen relativ selten verwendet.\n\n::: {.callout-note}\n## Merke\nDie ***Anwendungsgebiete*** von Zufallszahlen sind die **Krypografie** und die **Simualation**. \n:::\n\nIn den Datenwissenschaften sind Simulationen ein wichtiges Werkzeug für analytische und prediktive Modelle, insbesondere für die künstliche Intelligenz.\n\nR bietet die Funktion `runif()` zur Erzeugung von gleichmässig verteilten Zufallszahlen. Die Funktion generiert zufällig reelle Werte im Intervall von $\\left]0, 1 \\right[$. In diesem Zusammenhang bedeutet *gleichmässig verteilt*, dass alle Werte mit gleicher Wahrscheinlichkeit erzeugt werden.\n\n::: {.callout-note}\n## Merke\n*Gleichmässig verteilte* Werte werden auch als **uniforme** oder **uniform-verteilte** Werte bezeichnet.\n::: \n\n::: {#exm-runif}\n## Fünf Zufallswerte mit `runif()` erzeugen\n\n::: {.cell}\n\n```{.r .cell-code}\nrunif(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2149391 0.1571967 0.3644752 0.6747504 0.4993274\n```\n:::\n:::\n\n:::\n\nAus diesen Werten lassen sich beliebige Zufallsvektoren erzeugen. Um Werte in anderen Intervallen zu erzeugen, können der Funktion eigene Intervallgrenzen übergeben werden. \n\nWerden uniformverteilte Zufallswerte gegenübergestellt, dann sind diese Werte gleichmässig im Intervall verteilt (@fig-runif). \n\n\n::: {.cell warnings='false'}\n::: {.cell-output-display}\n![Visualisierung von Zufallswerten](kapitel_files/figure-html/fig-runif-1.png){#fig-runif width=672}\n:::\n:::\n\n\n::: {.callout-note}\n## Merke\nGanzzahlen dürfen nicht durch Runden , sondern müssen durch Entfernen des Nachkommaanteils mit `trunc()` erzeugt werden. \n::: \n\n::: {#exm-zufallsganzzahlen}\n## Zufällige Ganzzahlen in einem Intervall erzeugen\n\n::: {.cell}\n\n```{.r .cell-code}\nrunif(10, min = -10, max = 10) |> trunc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  6  7  9  9  9 -9 -5 -6 -5\n```\n:::\n:::\n\n::: \n\nNeben den uniformverteilten Werten, stellt R Funktionen zum Erzeugen von Zufallswerten mit anderen Verteilungen an. Die Grundlage für diese Zufallswerte bilden die *statistischen Verteilungen*, wie z.B. die Normalverteilung (mit `rnorm()`), die F-Verteilung (mit `rf()`), die Binomialverteilung (mit `rbinom()`) oder die $\\chi^2$-Verteilung (mit `rchisq()`). \n\nIn diesen Verteilungen sind nicht alle Werte gleich wahrscheinlich. Dadurch erscheinen in einer Visualisierung die Werte geklumpt (@fig-rnorm). \n\n\n::: {.cell warnings='false'}\n::: {.cell-output-display}\n![Visualisierung von normalverteilten Zufallswerten](kapitel_files/figure-html/fig-rnorm-1.png){#fig-rnorm width=672}\n:::\n:::\n\n::: {.cell warnings='false'}\n::: {.cell-output-display}\n![Visualisierung von $\\chi^2$-verteilten Zufallswerten](kapitel_files/figure-html/fig-rchisq-1.png){#fig-rchisq width=672}\n:::\n:::\n\n\n\n### Funktionen als Werte\n\n::: {.callout-note}\n## Merke\nEine Funktion ist für R ein Wert wie eine Zahl oder eine Zeichenkette. \n:::\n\nIm Fall von Funktionen ist der Wert einer Funktion die Funktionsdeklaration. Entsprechend ist es möglich Funktionen zu überschreiben. \n\nWird nur der Bezeichner einer Funktion eingegeben, gibt R die  Funktionsdefinition wie jeden anderen Wert direkt aus.  \n\n\n## Operatoren\n\nAlle R-Operatoren sind Funktionen. R kennt 29 vordefinierte Operatoren, die zwei Werte verknüpfen. Zu diesen Operatoren gehören die auch die arithmetischen Operatoren für die Grundrechenarten. \n\n| Operator | Beschreibung | Art | \n| :---: | :------- | :--- |\n| `+`\t| Plus, sowohl unär als auch binär | arithmetisch |\n|  `-` |\tMinus, sowohl unär als auch binär | arithmetisch |\n| `*`\t| Multiplikation, binär | arithmetisch |\n| `/`\t| Division, binär | arithmetisch |\n| `^`\t| Potenz, binär | arithmetisch |\n| `%%`\t| Modulo, binär | arithmetisch |\n| `%/%`\t| Ganzzahldivision, binär | arithmetisch |\n| `%*%`\t| Matrixprodukt, binär | arithmetisch, Matrix |\n| `%o%`\t| äusseres Produkt, binär | arithmetisch, Matrix |\n| `%x%`\t| Kronecker-Produkt, binär | arithmetisch, Matrix |\n| `<`\t| Kleiner als, binär |  logisch |\n| `>`\t| Grösser als, binär | logisch |\n| `==` | Gleich, binär | logisch |\n| `!=` | Ungleich, binär | logisch |\n| `>=` | Grösser oder gleich, binär | logisch |\n| `<=` | Kleiner oder gleich, binär | logisch |\n| `%in%` | Existenzoperator, binär | logisch |\n| `!` |\tunäres Nicht | logisch |\n| `&`\t| Und, binär, vektorisiert | logisch |\n| `&&`\t| Und, binär, nicht vektorisiert | logisch |\n| `|` |\tOder, binär, vektorisiert | logisch |\n| `||` | Oder, binär, nicht vektorisiert | logisch |\n| `<-`, `<<-`, `=` |\tlinksgerichtete Zuweisung, binär | Zuweisung |\n| `->`, `->>` |\trechtsgerichtete Zuweisung, binär | Zuweisung |\n| `[` | Indexzugriff (Vektoren), binär |  Index |\n| `$`, `[[`\t| Listenzugriff, binär | Index |\n| `~`\t| funktionale Abhängigkeit, sowohl unär als auch binär | Funktionen |\n| `:`\t| Sequenz (in Modellen: Interaktion), binär | Funktionen |\n| `?`\t| Hilfe | spezial |\n\n: Liste der Base R Operatoren {#tbl-r-operatorem}\n\n::: {.callout-note}\nIm R-Umfeld wird oft von **Modellen** geschrieben und gesprochen. *Modelle* sind *spezielle Funktionen*, die *Beziehungen zwischen Daten* beschreiben, ohne eine mathematisch exakte Beziehung vorzugeben. Modelle werden in der *Statistik* und *Stochastik* eingesetzt, wenn die exakten Beziehungen zwischen Daten unbekannt sind.\n:::\n\n::: {#exm-exakte-beziehung}\n## Exakte *lineare* Beziehung zwischen Daten\n```r\nf = function (x) 2 * x + 3\n```\n:::\n\n::: {#exm-beziehung-als-modell}\n## Beziehung zwischen Daten mit Interaktion als Modell\n```r\nf = y ~ x : c\n```\n:::\n\nHinter jedem Operator steht eine Funktion, die mit den beiden Operanden als Parameter ausgeführt wird, um das Ergebnis des Operators zu bestimmen. Daraus folgt, dass jeder Operator auch als Funktionsbezeichner verwendet werden kann. In diesem Fall muss R mitgeteilt werden, dass der Operator nun als Funktionsbezeichner verwendet werden soll. Der Operator muss also  mit Backticks als Bezeichner markiert werden.\n\n::: {#exm-plus-als-fkt}\n## `+`-Operator als Funktionsbezeichner\n\n::: {.cell}\n\n```{.r .cell-code}\n`+`(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n:::\n\n### Zuweisung\n\nR kennt zwei Zuweisungsoperatoren: `<-` und `->`. Die Zuweisung erfolgt in Richtung des Pfeils. Daneben wird der `=`-Operator ebenfalls als (inoffizieller) Zuweisungsoperator unterstützt. \n\nEin Zuweisungsoperator erwartet immer einen Bezeichner und eine Operation als Parameter. Das Ergebnis der Operation wird als Wert dem Bezeichner zugewiesen. \n\nWeil nicht immer klar ist, ob `<-` oder `=` verwendet werden soll, lautet die offizielle Kommunikation, dass für Variablenzuweisungen der `<-`-Operator verwendet werden sollte. Das einfache Gleich (`=`) weist einen Wert einem Funktionsparameter zu. Gerade in **tidy R** ist dieser Unterschied nur schwer nachvollziehbar, weil bestimmte Parameter wie Variablen behandelt werden.\n\n::: {.callout-note}\nIn diesem Buch wird für die *linksgerichtete Zuweisung* immer das  Gleichzeichen (`=`) verwendet, so dass eine Zuweisung eines Werts an eine Variable und an einen Parameter gleichwertig behandelt wird. Dadurch wird die Lesart etwas vereinfacht. Zusätzlich wird die rechtsgerichtete Zuweisung konsequent als Abschluss für einen primären Datenstrom (s. @sec-fkt-ketten) eingesetzt.\n:::\n\n### Funktionsausführung\n\nDer Ausführenoperator (`()`) gilt in R offiziell nicht als Operator, weil dieser nicht als Funktion umgesetzt werden kann. Es gibt zwar die Funktion `do.call()`, um eine Funktion auszuführen. Wenn diese Funktion als Ausführungsoperator eingesetzt wird,  müsste `do.call()` sich selbst aufrufen, um sich selbst auszuführen. Dieses Problem wird von R dadurch gelöst, dass `(` und  `)` als eigene *Symbole* erkannt werden und immer eine Funktionsausführung anzeigen.\n\n#### Hilfeoperator\n\nDer *Hilfeoperator* ist ein besonderer Operator, weil dieser die Interaktion mit der Dokumentation von Funktionen und Konzepten ermöglicht. Der Hilfeoperator wird normalerweise nicht in einem R-Script verwendet und hat keine Bedeutung für die Datenverarbeitung.\n\nDer Hilfeoperator kann direkt mit einem Bezeichner aufgerufen werden. Existiert für den Bezeichner eine Dokumentation, dann wird diese angezeigt.\n\n::: {#exm-hilfeop-funktionsname}\n## Dokumentation der Funktion `is.character()`\n```r \n?is.character\n```\n:::\n\nWird der Hilfeoperator mit sich selbst aufgerufen, wird der nächste Wert als Suchbegriff gewertete und eine Suche über alle Hilfedokumente auf dem System durchgeführt.\n\n::: {#exm-hilfeop-hilfeop}\n## Dokumentationssuche nach Operatoren\n```r\n??operator\n```\n::: \n\n## Funktionsketten {#sec-fkt-ketten}\n\nR unterstützt die spezielle Funktionsverkettung mit dem `|>`- Operator. Dadurch lassen sich Funktionsfolgen direkt in R ausdrücken. In Kombination mit der rechtsgerichteten Zuweisung (`->`) ist es möglich, Datenströme durch eine Funktionskette von einem Ausgangswert zu einem Ergebnis in der natürlichen Reihenfolge aufzuschreiben.\n\n::: {#exm-fktkette-datenstrom}\n## Funktionskette mit abschliessender Zuweisung\n```r\n# library(tidyverse)\niris |>\n    filter(Species == \"setosa\") |>\n    arrange(desc(Petal.Length)) -> \n        sortierteSetosaWerte\n```\n:::\n\nNeben der speziellen Funktionsverkettung (`|>`) gibt es einen sehr ähnlichen Verkettungsoperator: `%>%`. Dieser Verkettungsoperator ist Teil der `tidyverse`-Bibliothek und gleicht der speziellen Funktionsverkettung mit dem kleinen Unterschied, dass die Parameterzuweisung für die nachfolgende Funktion zusätzliche Kontrollmöglichkeiten bietet, die der speziellen Funktionsverkettung fehlen.  \n\n## Eigene Funktionen erstellen\n\nIn R werden Funktionen mit dem `function`-Schlüsselwort erstellt. Eine R-Funktion besteht aus einer Parameterliste und einem Funktionskörper. Die Parameterliste wird in Klammern hinter dem Wort `function` angegeben. Der Funktionskörper kann eine einzelne Operation oder ein Block sein. Das Ergebnis einer Funktion ist das Ergebnis der letzten Operation des Funktionskörpers.\n\n@exm-function-create zeigt eine *Funktionsdeklaration*, die einen `parameter` *akzeptiert*. Die Funktion quadriert diesen Wert und zieht vom Ergebnis `1` ab. An diesen Operationen wird erkannt, dass die Funktion nur Werte vom Datenyp Zahlen als `parameter` akzeptiert.\n\nParameter sind in R spezielle *Variablen*, mit denen Werte an eine Funktion übergeben werden. Parameter existieren nur *innerhalb* einer Funktion während der Ausführung des Funktionskörpers. Es kommt sehr häufig vor, dass ausserhalb einer Funktion Variablen mit gleichem Bezeichnern vorhanden sind. Ein Parameter überschreibt diese Variablen **nicht**.\n\n::: {#exm-function-create}\n## Eine Funktion deklarieren\n```r\nfunction (parameter) {\n    parameter ^ 2 - 1\n}\n```\n:::\n\nDamit eine Funktion sinnvoll verwendet werden kann, muss sie zuerst einer Variablen zugewiesen werden. Der Bezeichner einer Funktion sollte möglichst die zentrale Bedeutung einer Funktion beschreiben.\n\n::: {.callout-note}\nDie Wahl eines guten Funktionsbezeichners hängt vom jeweiligen Geltungsbereich ab.\n\nMathematische Funktionen werden oft mit $f(x)$ oder $g(x)$ usw. geschrieben. In R sind solche Bezeichner ebenfalls zulässig, solange sie **eindeutig** sind. Solche sehr kurzen Funktionsbezeichnern sollten speziell gekennzeichnet und dokumentiert werden.\n:::\n\n@exm-function-named-create weist der Funktion aus @exm-function-create den Bezeichner `quadrat_minus_eins` zu. Dieser Bezeichner kann anschliessend als Funktion verwendet werden (s. @exm-funktion-aufrufen).\n\n::: {#exm-function-named-create}\n## Eine Funktion mit Bezeichner deklarieren\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrat_minus_eins = function (parameter) {\n    parameter ^ 2 - 1\n}\n```\n:::\n\n:::\n\n::: {#exm-funktion-aufrufen}\n## Eine selbstdeklarierte Funktion aufrufen\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrat_minus_eins(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n:::\n\n### Parameter und Variablen\n\nEin Parameter ist ein Platzhalter für einen Wert, der einer Funktion beim Funktionsaufruf übergeben wird. Parameter werden für eine spezielle Form der Variablenzuweisung eingesetzt. \n\nIm Funktionskörper verhält sich ein Parameter wie eine Variable. Einem Parameter können also in einem Funktionskörper neue Werte zugewiesen werden. Neben Parametern können Funktionskörper zusätzliche Variablen benötigen. Der Geltungsbereich dieser Variablen sind auf den Funktionskörper beschränkt.\n\n### Datentypen überprüfen\n\nWird der neuen Funktion ein falscher Datentyp als Parameter übergeben, dann können die Rs Fehlermeldungen sehr verwirrend sein. Es ist daher ein guter Stil, Parameter die bestimmte Datentypen erfordern direkt zu Begin des Funktionskörpers zu prüfen (s. @exm-fkt-datentyp-prüfen).\n\n::: {#exm-fkt-datentyp-prüfen}\n## Eine Funktion mit Typenprüfung deklarieren\n```r\nquadrat_minus_eins = function (parameter) {\n    stopifnot(is.numeric(parameter))\n    parameter ^ 2 - 1\n}\n```\n:::\n\n### Nebeneffekte {#sec-nebeneffekte}\n\n::: {.callout-important}\n**Nebeneffekte** sind in (fast) immer unerwünscht. Die in diesem Abschnitt werden die beiden speziellen Zuweisungsoperatoren `<<-` und `->>` vorgestellt, die gezielt **Nebeneffekte** erzeugen.\n\nDieser Abschnitt beschreibt einen Sonderfall der Variablen- oder Funktionsdeklaration in **speziellen *Closures*** (s.u.), der in R **sehr selten** vorkommt. Die meisten Algorithmen lassen sich *nebeneffektsfrei* Programmieren, weshalb die beiden speziellen Zuweisungsoperatoren normalerweise nicht verwendet werden.\n:::\n\nDer Funktionskörper bildet einen abgegrenzten Geltungsbereich für Variablen. Alle normalen Zuweisungen gelten nur für den Funktionskörper, selbst wenn eine Variable oder ein Parameter ursprünglich in einem äusseren Geltungsbereich deklariert wurde.\n\n::: {#exm-variablen-decl}\n## Geltungsbereich von Variablen in Funktionen\n\n::: {.cell}\n\n```{.r .cell-code}\n# Deklarationen\nvar1 = 1\nf = function (x) {\n    var1 = x + var1\n    var1\n}\n\n# Anwendung\nf(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nvar1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n:::\n\nIn ***seltenen Fällen*** ist es notwendig, eine Variable eines äusseren Geltungsbereichs in einer Funktion einen neuen Wert zuzuweisen. Hier kommen die speziellen Zuweisungen `<<-` und `->>` zum Einsatz. Wird anstelle einer normalen Zuweisung die spezielle Zuweisung verwendet, dann wird einer Variablen oder einem Parameter eines äusseren Geltungsbereich ein neuer Wert zugewiesen. \n\n::: {#def-nebeneffekt}\nÄndert eine Funktion eine Variable eines äusseren Geltungsbereichs, dann ist diese Änderung ein **Nebeneffekt** der Funktion. \n:::\n\n::: {#exm-function-sideeffect}\n## Funktion mit Nebeneffekt\n\n::: {.cell}\n\n```{.r .cell-code}\n# Deklarationen\nvar1 = 1\nf = function (x) {\n    x + var1 ->> var1\n    var1\n}\n\n# Anwendung\nf(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nvar1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n:::\n\n::: {.callout-tip}\n## Praxis\nIn R sollten ausschliesslich *Closures* Nebeneffekte haben, wenn eine Closure eine Variable einer generierenden Funktion ändern muss. ***Dieser Fall tritt sehr selten ein!***\n:::\n\n\n::: {.callout-important}\nVariablen mit globalem Geltungsbereich sollten **nie** durch Nebeneffekte geändert werden. \n:::\n\n::: {.callout-note}\n**Objektorientierte Sprachen**, wie Python oder Java, verwenden Nebeneffekte als zentrales Programmierprinzip.\n\n**Streng-funktionale Sprachen**, wie Excel, sind ***nebeneffektfrei***.\n:::\n\n## Bibliotheken\n\nOft ist es nicht notwendig eigene Funktionen zu erstellen. Stattdessen kann in vielen Fällen auf Funktionsbibliotheken zurückgegriffen werden, die bereits entsprechende Funktionen bereitstellen. \n\nR wird durch Funktionsbibliotheken erweitert. Eine Funktionsbibliothek stellt hauptsächlich Funktionen und Operationen für bestimme Algorithmen oder Analysemethoden bereit. Eine Funktionsbibliothek wird mit der Funktion `install.packages()` auf einem Rechner installiert. \n\nIn einem R-Script lassen sich die Funktionen einer Bibliothek auf zwei Arten nutzen:\n\n1. Die Bibliothek wird mithilfe der Funktion `library()` in den Code eingebunden. \n2. Eine Funktion einer Bibliothek wird direkt angesprochen. \n\nDie erste Option bietet sich an, wenn ein Script viele Funktionen einer Bibliothek aufrufen wird. R läd in diesem Fall *alle Funktionen* der Bibliothek, so dass diese direkt verwendet werden können.\n\n::: {#exm-fkt-library-load}\n## Funktionen mit der `library()` Funktion einbinden\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nmtcars |> \n    ggplot(aes(mpg, hp)) +\n        geom_point()\n```\n\n::: {.cell-output-display}\n![](kapitel_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n:::\n\nDie zweite Option ist sinnvoll, wenn nur eine oder zwei Funktionen einer Bibliothek verwendet werden sollen. In diesem Fall muss R nicht die gesamte Bibliothek bereitstellen, sondern läd gezielt nur die gewünschten Funktionen. \n\n::: {#exm-fkt-direct-access}\n## Eine Funktion direkt ansprechen\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n    dplyr::filter(hp > 200)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                     mpg cyl disp  hp drat    wt  qsec vs am gear carb\nDuster 360          14.3   8  360 245 3.21 3.570 15.84  0  0    3    4\nCadillac Fleetwood  10.4   8  472 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8  440 230 3.23 5.345 17.42  0  0    3    4\nCamaro Z28          13.3   8  350 245 3.73 3.840 15.41  0  0    3    4\nFord Pantera L      15.8   8  351 264 4.22 3.170 14.50  0  1    5    4\nMaserati Bora       15.0   8  301 335 3.54 3.570 14.60  0  1    5    8\n```\n:::\n:::\n\n:::\n\n::: {.callout-note}\nR bietet sog. Meta-Bibliotheken an, mit denen mehrere Bibliotheken gemeinsam verwendet werden können. Funktionen können nur nicht über den Namen einer Meta-Bibliothek, sondern immer nur über die Bibliothek, die einer Funktion definiert. \n:::\n\nDie `tidyverse`-Bibliothek ist eine solche Meta-Bibliothek. @exm-fkt-dir-ansprechen-meta zeigt wie die Funktion `read_delim()` direkt angesprochen werden kann, wenn die `tidyverse`-Bibliotheken nicht mit `library(tidyverse)` eingebunden wurden. `read_delim()` wird in der Bibliothek `readr` definiert. Entsprechend kann die Funktion nur über `readr::read_delim()` aufgerufen werden.\n\n::: {#exm-fkt-dir-ansprechen-meta}\n## Funktion aus Unterbibliothek direkt ansprechen\n```r\nreadr::read_delim(\"meine_daten.csv\")\n# entspricht:\n#   library(tidyverse)\n#   read_delim(\"meine_daten.csv\")\n```\n:::\n\n::: {.callout-note}\nDie Syntax von R kann durch Module erweitert werden. Diese Form nutzt die Konzepte zur **Metaprogrammierung** von R. Dadurch können neue Programmierkonzepte in die Sprache einfliessen. Die `tidyverse`-Bibliotheken nutzen diese Möglichkeit intensiv. Solche Bibliotheken **müssen** mit der Funktion `library()` eingebunden werden, damit die zusätzliche Syntax bereitgestellt wird.\n::: \n\n## Bibliotheken verwalten\n\nVerwendet ein R-Script Funktionsbibliotheken, dann ist dieses Script nur auf Rechnern lauffähig, auf denen die benutzten Bibliotheken auch installiert sind. Solche notewendigen Bibliotheken heissen die **Abhängigkeiten** (engl. *dependencies*) eines Scripts. Weil sich die Abhängikeiten nicht immer leicht erkennen lassen, müssen alle Abhängigkeiten müssen dokumentiert werden. \n\n::: {.callout-tip}\n## Praxis\n\nIm Internet gibt es sehr viele Beispiele, die die Funktion `install.packages()` als Teil des Programmcodes darstellen. In konkreten R-Projekten sollte die Funktion `install.packages()` **nie** in einem normalen R-Script aufgerufen werden, weil bei jedem Start des Script geprüft wird, ob eine neue Version der Bibliothek existiert. Diese Technik stellt ein Sicherheitsrisiko dar, weil bei jeder Ausführung des Scripts Installationen unkontrolliert vorgenommen werden können und Schadcode auf die Systeme geschleust werden kann. \n\nDas Risiko unkontrollierter Installationen wird verringert, indem Installationen von der Programmlogik getrennt und nur kontrolliert durchgeführt werden. Dadurch wird die Installation von Funktionsbibliotheken von ihrer Anwendung getrennt.\n:::\n\nDie Dokumentation von Abhängigkeiten wird normalerweise von einem sog. Packetmanagement übernommen. R verfügt über *kein integriertes* Packetmanagement. Dieses wird von der Bibliothek `renv` übernommen. Bevor dieses genutzt werden kann muss `renv` mit `install.packages(\"renv\")` installiert werden. \n\n::: {.callout-tip}\n## Praxis\n`renv` sollte bei der Installation von R gleich mitinstalliert werden.\n:::\n\n`renv` ist ein Packetmanagementsystem für R. Anders als die Funktion `install.packages()` installiert `renv` nicht nur Bibliotheken, sondern dokumentiert auch die Abhängigkeiten eines Projekts in einer Form, dass alle Abhängigkeiten einfach auf dem System installiert werden können. Mit `renv::restore()` lässt sich ein Projekt in einer anderen Umgebung mit allen Abhängigkeiten konfigurieren und ausführen. \n\nWird eine Bibliothek mit `renv` installiert, dann steht diese Bibliothek nur dem jeweiligen Projekt zur Verfügung. Was auf dem ersten Blick als Nachteil klingt, ist ein grosser Vorteil, wenn unterschiedliche Projekte besonderen Anforderungen an die Versionen einer Bibliothek haben. Auf diese Weise kann jedes Projekt die richtige Version einer Bibliothek verwenden und beeinflusst keine anderen Projekte.\n\n### Projektvorbereitung\n\nEin Projekt wird mit `renv::init()` für die Verwendung des Packetmanagements vorbereitet. Beim ersten Aufruf von `renv` werden die internen Abhängigkeiten von `renv` kontrolliert und notfalls installiert. Das nimmt etwas Zeit in Anspruch. \n\nDas Packetmanagement erfasst automatisch alle Bibliotheken, die systemweit installiert wurden. Dadurch wird sichergestellt, dass alle Bibliotheken berücksichtigt wurden, die im eigenen System installiert sind und deshalb auch im Projekt verwendet werden können. Die Einzige Ausnahme davon ist `renv` selbst.\n\n### Bibliotheken installieren\n\nNach der Initialisierung des Packetmanagements können projektspezifische Bibliotheken mit `renv::install()` installiert werden. War eine Installation erfolgreich, sollte die Bibliothek auf ihre Funktionstüchtigkeit mit einem einfachen Beispiel geprüft und danach mit `renv::snapshot()` als Abhängigkeit dokumentiert werden. Mit einem *Snapshot* wird eine Bibliotheksversion als Abhängigkeit registiert. Im Gegensatz zu `install.packages()` wird ab diesem Zeitpunkt nicht mehr eine beliebige Version der Bibliothek installiert, sondern nur die dokumentierte Version. Dadurch wird sichergestellt, dass der Code auch in anderen Umgebungen wie erwartet funktioniert. \n\n### Bibliotheken updaten \n\nEine Besonderheit von `renv` ist die Möglichkeit, kontrollierte Updates für einzelne oder alle Abhängigkeiten eines Projekts mit `renv::update()` durchzuführen. `renv::update()` installiert die neusten Versionen der Projektbibliotheken. \n\n::: {.callout-note}\n## Merke\nUpdates sollten nie unklontrolliert akzeptiert werden!\n:::\n\nBevor neue Bibliotheksversionen in das Packetmanagement aufgenommen werden, sollte immer geprüft werden, ob der bestehende Code mit den neuen Versionen immer noch funktioniert. Sollten bei dieser Prüfung Probleme auftreten, dann können die Updates mit `renv::revert()` wieder rückgängig gemacht werden. Gab es keine Probleme, dann können die Updates mit  `renv::snapshot()` übernommen werden. \n",
    "supporting": [
      "kapitel_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}