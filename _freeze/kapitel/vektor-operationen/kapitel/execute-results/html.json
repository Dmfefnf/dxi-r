{
  "hash": "f221a31653431995f96de764cee04769",
  "result": {
    "markdown": "---\nabstract: \"\"\n---\n\n# Vektoroperationen {#sec-chapter-vektoroperationen}\n\n::: {.callout-warning}\n## Work in Progress\n:::\n\n\n\n\n\n**Vektoren** sind zusammengesetzte Datenstrukturen, die Werte vom gleichen Datentyp enthalten. In R bilden Vektoren die Basisstruktur für *alle Daten*. R unterscheidet zwischen Listen und Vektoren, wobei für Vektoren immer sichergestellt wird, dass alle Werte vom gleichen Datentyp sind.\n\n::: {.callout-warning}\n## Wichtig\nVektoren haben in R keine Orientierung, d.h. R unterscheidet nicht zwischen Zeilen- und Spaltenvektoren. \n:::\n\n::: {.callout-note}\n## Merke\nAlle R-Vektoren werden grundsätzlich als Spaltenvektoren behandelt.\n::: \n\n## Konkatenation\n\nVektoren werden in R mit der Funktion `c()` erzeugt (@exm-vektor-erstellen). \n\n::: {#exm-vektor-erstellen}\n## Einen Vektor aus Skalaren erstellen\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor = c(2, 3, 1, 5, 4, 6)\nvektor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 1 5 4 6\n```\n:::\n:::\n\n:::\n\nDie Funktion `c()` dient nicht nur zum erzeugen von Vektoren, sondern auch zur Konkatenation von Vektoren (@exm-konkatenation). Anders als mit der `list`-Funktion, können mit der `c()`-Funktion keine komplexen Datenstrukturen erzeugt werden.\n\n::: {#exm-konkatenation}\n## Konkatenation von Vektoren\n\n::: {.cell}\n\n```{.r .cell-code}\nc(vektor, c(6, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 1 5 4 6 6 7\n```\n:::\n:::\n\n:::\n\n::: {.callout-tip}\n## Praxis\n\nDie Funktion `c()` sollte nur zur Konkatenation von alleinstehenden Vektoren eingesetzt werden und nie für Vektoren, die zu einem Datenrahmen gehören!\n:::\n\n## Vektorlänge\n\nDie Länge eines R-Vektors wird mit der Funktion `length()` bestimmt. Diese Funktion liefert immer eine ganze Zahl mit der Anzahl der Vektorelemente (@exm-vektorlaenge).\n\n::: {#exm-vektorlaenge}\n## Vektorlänge bestimmen\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 3, 2, 4) |> length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n:::\n\nR kennt den leeren Vektor. Dieser Vektor hat die Länge `0`. Er wird durch den argumentlosen Aufruf der Funktion `c()` erzeugt (@exm-vektorlaenge-zerovector). \n\n::: {#exm-vektorlaenge-zerovector}\n## Vektorlänge des leeren Vektors\n\n::: {.cell}\n\n```{.r .cell-code}\nc() |> length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n:::\n\n## Wertereferenzierung\n\nJeder Wert in einem Vektor hat eine eindeutige Position. Der erste Wert hat die Position `1` und alle weiteren Positionen sind fortlaufend nummeriert. Der Wert der Position wird auch als *Vektorindex* bezeichnet. \n\nDer Index eines Vektors wird in eckigen Klammern (bzw. Blockklammern: `[` und `]`) gerahmt angegeben. Die Blockklammern sind R's *Indexoperator*. Ein Index wird als ***Referenz*** für einen Wert verwendet. Ein Wert in einem Vektor wird über den Index referenziert.\n\nEs werden drei Varianten der Wertereferenzierung unterschieden. Alle Varianten sind gleichwertig, dürfen aber nicht gemischt werden.\n\n- Die Indexreferenz\n- Die negative Indexreferenz\n- Die Referenz mit Wahrheitsvektoren\n\n### Indexreferenz\n\n::: {#exm-wertezugriff-einzeln}\n## Index eines Vektors\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n:::\n\nWeil alle Werte gleichzeitig Vektoren sind, können Indizes ebenfalls als Vektoren angegeben werden, um mehrere Vektorwerte gleichzeitig abzufragen. Der Ergebnisvektor enthält die Werte in der Reihenfolge \n\n::: {.callout-warning}\n## Achtung\nWerden ungültige Indizes angegeben, füllt R diese nicht existierenden Werte mit `NA` auf. \n::: \n\n::: {#exm-wertezugriff-vektor}\n## Vektorwerte über einen Indexvektor abfragen\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor[c(2, 7, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3 NA  5\n```\n:::\n:::\n\n:::\n\nEin Indexvektor kann länger als der Wertevektor sein, ausserdem können Indexwerte wiederholt werden. Dadurch lassen sich Vektoren systematisch erzeugen. \n\n::: {#exm-wertezugriff-vektor-wiederholung}\n## Vektorwerte über einen Indexvektor wiederholt abfragen\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor[c(2, 4, 4, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 5 5 3\n```\n:::\n:::\n\n:::\n\n### Negative Indexreferenz\n\nAlternativ können *negative* Indizes verwendet werden. Das Vorzeichen bedeutet in diesem Fall *\"ausser\"*. Es werden also alle Indizes, ausser dem angegebenen, zurückgegeben [@r_core_team_introduction_2023].\n\n::: {.callout-warning}\n## Achtung\nNegative und positive Indizes dürfen nicht gemischt werden!\n:::\n\n::: {.callout-important}\n## Jargon\n\nDiese Verwendung von negativen Referenzen ist eine Eigenheit von R und wird in den meisten anderen Programmiersprachen nicht bzw. nicht so unterstützt. \n:::\n\n::: {#exm-wertezugriff-negativindex}\n## Negative Indizes\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor[-2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1 5 4 6\n```\n:::\n:::\n\n:::\n\n### Referenz durch Wahrheitsvektoren\n\nDie letzte Variante des Wertezugriffs ist der Zugriff mit einem Wahrheitsvektor. Ein Wahrheitsvektor zum Wertezugriff **muss** die gleiche Länge haben, wie der Wertevektor. Das Ergebnis dieser Operation ist ein Vektor, der nur Werte enthält, die an den Positionen stehen, an welchen im Wahrheitsvektor `TRUE` steht. \n\n::: {#exm-wertezugriff-wahrheitsvektor}\n## Negative Indizes\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor[c(TRUE, FALSE, TRUE, FALSE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1 4 6\n```\n:::\n:::\n\n:::\n\n\nDiese Art des Wertereferenzierung wird häufig mit einer Transformation ([Abschnitt @sec-transformationen]) als Teil eines logischen Ausdrucks kombiniert. @exm-ref-transform referenziert nur die gereaden Werte in `vektor`.\n\n::: {.callout-note}\n## Merke\nDas Referenzieren mit einem logischen Ausdruck ist eine Variante des Filterns.\n:::\n\n::: {.callout-tip}\n## Praxis\n\nDas Filtern durch Referenzieren sollte nur für alleinstehende Vektoren eingesetzt werden. Zum Filtern von Vektoren in Datenrahmen sollte **immer** die `dplyr`-Funktion `filter()` verwendet werden. \n:::\n\n::: {#exm-ref-transform}\n## Gerade Werte aus einem Vektor auswählen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor[vektor %% 2 == 0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6\n```\n:::\n:::\n\n:::\n\n## Sequenzen\n\nSequenzen werden mit der Funktion `seq()` erstellt. Die Funktion hat fünf Parameter. Die drei wichtigsten Parameter sind: \n\n- `from`:  Der Initialwert der Sequenz.\n- `length`: Die Länge der Sequenz.\n- `by`: Die Schrittweite der Sequenz.\n\nNeben diesen Parameter gibt es noch die beiden Parameter: \n\n- `to`: Der Endwert der Sequenz\n- `along.with`: Übernimmt die Länge der Sequenz der Länge des angegebenen Vektors.\n\n::: {#exm-sequenzen-erstellen}\n## Sequenzen erstellen\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(5) # seq(length = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nseq(2, 5) # seq(from = 2, to = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nseq(from = 2, length = 5, by = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n:::\n\nNeben der `seq()`-Funktion kennt R den Sequenzoperator `:`. Die Operanden des Squenzoperators sind der Initial- und Endwert, wobei eine Schrittweite von `1` angenommen wird (@exm-sequenzen-erstellen).\n\n::: {#exm-sequenzen-erstellen}\n## Sequenzoperator verwenden\n\n::: {.cell}\n\n```{.r .cell-code}\n3:8  # identisch mit seq(from = 3, to = 8, by = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5 6 7 8\n```\n:::\n:::\n\n:::\n\n## Wiederholungen\n\nVektoren mit gleichen Werten an allen Positionen können als Sequenzen mit der Schrittweite von `0` verstanden werden. Genauso lassen sich solche Vektoren als Wiederholungen eines Werts beschreiben. Diesen Weg geht R mit der `rep()`-Funktion (rep für engl. *repeat*). \n\nDie `rep()`-Funktion hat zwei Parameter: \n\n- `x`: Der Wiederholungswert\n- `length`:  Die Länge des Zielvektors\n\nMit dieser Funktion lassen sich Vektoren wie der Nullvektor oder der Einsvektor leicht erzeugen (@exm-repeat-vektor-erzeugen).\n\n::: {#exm-repeat-vektor-erzeugen}\n## Null- und Einsvektor der Länge fünf erzeugen\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(0, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0 0\n```\n:::\n\n```{.r .cell-code}\nrep(1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 1 1 1\n```\n:::\n:::\n\n:::\n\nWeil die Datengrundstruktur in R Vektoren sind, können Vektoren mit der `rep()`-Funktion vervielfacht werden. So lassen sich Vektoren mit Wertemustern erzeugen (@exm-repeat-vektor).\n\n::: {#exm-repeat-vektor}\n## Mustervektor erzeugen\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(1,0), 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0 1 0 1 0\n```\n:::\n:::\n\n:::\n\n## Transformationen {#sec-transformationen}\n\nVektortransformationen bedeuten in R das wiederholte Ausführen einer Funktion für jeden Wert eines Vektors. Alle arithmetischen, logischen und Vergleichsoperatoren sind automatisch Vektortransformationen (@exm-vector-transform).\n\n::: {#exm-vector-transform}\n## Einfache Vektortransformationen\n\n::: {.cell}\n\n```{.r .cell-code}\n# Arithmetische Operationen\nvektor + 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  7  5  9  8 10\n```\n:::\n\n```{.r .cell-code}\nvektor %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 1 1 0 0\n```\n:::\n\n```{.r .cell-code}\n# Logische und Vergleichsoperationen\nvektor <= 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n2 < vektor & vektor < 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE FALSE  TRUE FALSE\n```\n:::\n:::\n\n:::\n\nEine Besonderheit von R ist die Verallgemeinerung von Skalaroperationen auf Vektoren mit *unterschiedlicher* Länge. Dabei wird der kürzere Vektor auf die Länge des längeren Vektors durch Wiederholung erweitert, so dass eine Vektortransforamtion möglich wird (@exm-vector-vector-transform). Bei einer Vektortransformation werden die Werte an den gleichen Positionen aus zwei Vektoren paarweise miteinander verknüpft.\n\n::: {#exm-vector-vector-transform}\n## Erweiterte Vektortransformationen\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 1 5 4 6\n```\n:::\n\n```{.r .cell-code}\nvektor + 4 # vektor + rep(4, length(vektor))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  7  5  9  8 10\n```\n:::\n\n```{.r .cell-code}\nvektor + c(1, 2) # vektor + rep(c(1, 2), 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 5 2 7 5 8\n```\n:::\n:::\n\n:::\n\nIm @exm-vector-vector-transform werden Vektoren mit Längen, die Vielfache des kürzesten Vektors sind. Dadurch ist sichergestellt, dass keine überzähligen Werte bleiben. Die Wiederholung des kürzeren Vektors wird auch dann ausgeführt, wenn die Vektorenlängen keine Vielfachen voneinander sind. Dabei wird die Operation nur für alle die Werte im ursprünglich längsten Vektor ausgeführt. Dadurch bleiben nicht verwendete Werte im wiederholten Vektor. Diese überbleibenden Werte erzeugen eine Warnmeldung (@exm-vector-vector-transform-incomplete).  \n\n::: {#exm-vector-vector-transform-incomplete}\n## Unvollständige Vektortransformationen\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 1 5 4 6\n```\n:::\n\n```{.r .cell-code}\nvektor + c(1, 2, 3, 4, 5) # vektor + c(1, 2, 3, 4, 5, 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in vektor + c(1, 2, 3, 4, 5): Länge des längeren Objektes\n \t ist kein Vielfaches der Länge des kürzeren Objektes\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 5 4 9 9 7\n```\n:::\n:::\n\n:::\n\nDie Vektoroperationen von R sind sehr flexibel und leistungsfähig. Allerdings lassen sich auch damit nicht alle beliebigen Vektortransformationen durchführen.\n\n::: {.callout-note}\n## Merke\nBeliebige Transformationen lassen sich mit `map()` aus der Bibliothek `purrr()` umsetzen.\n:::\n\nDie `map()`-Funktion hat immer eine Liste als Ergebnis einer Vektortransforamtion. Der eigentliche Vektor ist in dieser Liste geschachtelt und muss mit `unlist()` extrahiert werden (@exm-map). \n\n## Aggregationen\n\nAggregationen fassen mehrere Werte eines Vektors zusammen.Das Ergebnis ist ein Vekter, der höchstens so lang ist, wie der aggregierte Vektor. Alle Aggregationen werden in R durch Funktionen realisiert. Eine solche Funktion heisst *Aggregator*. \n\nHäufig verwendete Aggregatoren sind: \n\n- `sum()`, zum Addieren aller Werte eines Vektors.\n- `mean()`, zur Mittelwertbildung.\n- `max()`, zum Finden des grössten Werts eines numerischen Vektors\n- `min()`, zum Finden des kleinsten Werts eines numerischen Vektors\n\nDas Filtern ist eine spezielle Aggregation, die zu einem neuen und oft kürzeren Vektor führt. Das Filtern von Werten eines einzelnen Vektors erfolgt über die Wertereferenzierung mit einem logischen Ausdruck (@exm-ref-transform).\n\nFür häufig verwendete Aggregationen finden sich in R eigene Funktionen. Sollte eine spezielle Aggregation ausnahmsweise nicht existieren, dann kann eine spezieller Aggregator implementiert werden.\n\n::: {.callout-note}\n## Merke\nBeliebige Vektoraggregationen lassen sich mit `reduce()` aus der Bibliothek `purrr` umsetzen.\n:::\n\n::: {.callout-important}\nImplementieren Sie keinen Aggregator, falls eine entsprechende Funktion bereits existiert. Die meisten vordefinierten Aggregatoren sind effizienter umgesetzt, als es mit einer naiven Umsetzung in R möglich wäre.\n:::\n\nBeim Reduzieren wird eine Reduktionsfunktion nacheinander auf die Werte eines Vektors ausgeführt, wobei das Zwischenergebnis im nächsten Schritt als Argument verwendet wird.\n\nDie `reduce()`-Funktion erwartet einen Vektor `.x` und eine Reduktionsfunktion `.f` als Parameter. Die Reduktionsfunktion ist eine zwei-parametrige Funktion (bzw. Operator), wobei der erste Parameter als **Akkumulator** bezeichnet wird und das Zwischenergebnis des vorangegangenen Reduktionsschritts enthält. \n\n::: {#exm-sum-als-reduktion}\n## Summe als Reduktion\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor |> reduce(function(acc, wert) { acc + wert }) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n\n```{.r .cell-code}\n# oder kürzer \nvektor |> reduce(`+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n:::\n\n::: \n\nFalls die Reduktionsfunktion auch für den ersten Wert in einem Vektor ausfgeführt werden soll, muss zusätzlich ein Initialwert angegeben werden. Typische Initialwerte für eine Reduktionsfunktion sind die neutralen Elemente der wichtigsten Operationen: \n\n- `0` (neutrales Element der Addition)\n- `1` (neutrales Element der Multiplikation)\n- `TRUE` (neutrales Element des logischen Und)\n- `FALSE` (neutrales Element des logischen Oder)\n- `\"\"` (leere Zeichenkette, neutrales Element der Textverkettung)\n- `c()` (leerer Vektor, neutrales Element der Konkatenation)\n\nEine spezielle Form der Reduktion steht mit der `purrr`-Funktion `accumulate()`. Während `reduce()` nur das Endergebnis der Reduktion liefert, gibt `accumulate()` auch die Zwischenergebnisse. Das Ergebnis der `accumulate()` Funktion ist immer ein Vektor mit der gleichen Länge wie der ursprüngliche Vektor. \n\n::: {#exm-sum-als-reduktion}\n## Laufende Summe als Reduktion mit `accumulate()`\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor |> accumulate(`+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  5  6 11 15 21\n```\n:::\n:::\n\n::: \n\n## Zählen\n\nMit der Funktion `length()` lassen sich die Werte in einem Vektor zählen. \n\n::: {.callout-note}\nIn der Literatur wird das Zählen von Werten regelmässig hinter komplexen Algorithmen verborgen. Gelegentlich müssen Werte als Teil einer komplexen Analyse gezählt werden. Um unnötigen Code zu vermeiden oder um übermässig komplexe formulierte Arbeitsschritte zu erkennen, ist es notwendig die wichtigsten Varianten des Zählens zu kennen. \n:::\n\n### Zählen durch Summieren\n\nBeim Zählen durch Summieren werden zählbare Einheiten durch eine `1` markiert und von nicht-zählbaren Einheiten getrennt, die mit einer `0` markiert wurden. Dadurch entsteht ein Vektor, der nur aus den Werten `0` und `1` besteht. Durch das Bilden der Summe ergibt sich die Anzahl der zählbaren Elemente. \n\nDer erste Schritt lässt sich durch einen logischen Ausdruck umsetzen. Der zweite Schritt  wird mit R's Summe-Funktion `sum()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(vektor > 3) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n### Zählen durch Filtern\n\nBeim Zählen durch Filtern werden die zählbaren Einheiten in einem separaten Vektor isoliert. Anschliessend muss nur die Länge dieses Vektors ermittelt werden. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor[vektor > 3] |> length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n### Zählen durch Nummerieren\n\nBeim Zählen durch Nummerieren wird ein zweiter Vektor mit den Nummern der zählbaren Einheiten verwendet. Das Maximum der Nummerierung entspricht der Anzahl der nummerierten Elemente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvektor2 = 1 : length(vektor)\n\nmax(vektor2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\n::: {.callout-tip}\n## Praxis\nIn der Regel wird dieser Vektor nicht für das Zählen neu erzeugt. Stattdessen wird dieser Vektor oft für eine andere Operation erzeugt und zum Zählen wiederverwendet.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}