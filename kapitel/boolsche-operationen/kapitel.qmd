---
# bibliography: references.bib

abstract: ""
---

# Boole'sche Operationen {#sec-chapter-booleans}

::: {.callout-warning}
## Work in Progress
::: 

```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/Users/glah/code/kurse/dxi-beispiele")
```

```{r}
#| echo: false
#| warning: false

library(tidyverse)
```

In R stehen die logischen Operationen als *binäre* Operatoren zur Verfügung, bzw. als Funktionen mit genau zwei Parametern. Diese logischen Operatoren sind vektorisiert. Es ist deshalb unnötig, logische Ausdrücke durch die Boole'sche Arithmetik zu ersetzen. Lediglich die Reihenfolge der Ausführung dieser Opeartoren folgt der gleichen Regel wie die Arithmetik. 

::: {.callout-note}
## Merke
* Das logische Und entspricht der Multiplikation.
* Das logische Oder entspricht der Addition.
:::

Daraus folgt, dass immer zuerst das logische Und und erst danach das logische Oder ausgewertet wird. Dieser Regel folgt auch R. 

Die @tbl-logische-operatoren stellt die logischen Operationen und die verschiedenen Schreibweisen gegenüber.

| Operation | neutrales Element |  Mathematisch |  R |  arithmetische Operation |
| :--- | :--- | :--- | :---: | :---: |
| Nicht | - | $$ \lnot $$ |  `!`  | $1 - a$ | 
| Und | WAHR |  $$ \land $$ | `&` |  $a \cdot b$ | 
| Oder  | FALSCH | $$ \lor $$ |  `|`  | $a + b$ |
| Exklusiv-Oder/Antivalenz  |  - | $$ \oplus $$ | `xor() `  |  (a - b)^2 |

: Die wichtigsten logischen Operatoren und ihre Entsprechung in R {#tbl-logische-operatoren}

::: {.callout-warning}
## Achtung
Es gibt neben den beiden Operatoren `&` und `|` auch die gedoppelte Varianten `&&` und `||`. Diese Varianten arbeiten auf den Binärwerten von Ganzzahlen und werden normalerweise **nicht** im Zusammenhang mit logischen Ausdrücken verwendet. 
::: 

Das **Logisches Nicht** wird in R durch den Nicht-Operator (`!`) ausgedrückt. Dieser Operator wird auf jeden Wert eines Vektors einzeln angewandt. 

::: {#exm-logisches-nicht}
## Logisches Nicht

```{r}
logischer_vektor = c(TRUE, FALSE, FALSE, TRUE, TRUE)

! logischer_vektor 
```
:::

R wandelt numerische Werte automatisch in Wahrheitswerte um, wenn sie mit logischen Operationen verwendet werden. Dabei gilt: 

* `FALSE` entspricht `0`
* `TRUE` entspricht *ungleich* `0`

::: {#exm-autoconvert-not}
```{r}
! c(1, 2, 0, 4, 0) 
```
:::

Wenn Sie in R zwei Vektoren mit dem Und- (`&`), dem Oder-Operator (`|`) oder der  Antivalenz (`xor()`) verknüpfen, dann werden die Werte **immer** *paarweise* miteinander verglichen. Ein einzelner Vektor kann nicht an die Funktion des jeweiligen Operators übergeben werden. 

**Beispiel paarweise Verknüpfung**

```{r}
vektor_a = c(TRUE, FALSE, FALSE, TRUE, TRUE)
vektor_b = c(TRUE,  TRUE, FALSE, FALSE, TRUE)

vektor_a & vektor_b 
```
## Logische Aggregationen mit `reduce()`

::: {.callout-note}
## Merke
Um logische Vektoren in **R** zu aggregieren, muss der Vektor **reduziert** (engl. *reduce*) werden. Das *Reduzieren* ist eine besondere *Aggregation* über eine Reihe von Werten, bei der jeder Wert gemeinsam mit dem Ergebnis der Vorgängerwerte an eine Funktion übergeben wird.
:::

::: {#exm-logical-reduce}
## Aggregation logischer Vektoren

```{r}
beispielWerte = c(TRUE, TRUE, FALSE, TRUE)

beispielWerte |> reduce(`&`)   
beispielWerte |> reduce(`|`)   
beispielWerte |> reduce(`xor`) 
```
:::

::: {.callout-important}
Beim Reduzieren muss beachtet werden, dass eine Funktion und nicht den Operator übergeben wird. Deshalb muss der jeweilige logische Operator in Backticks (`` ` ``) gesetzt und so als Funktionsbezeichner markiert werden. 
:::

## Vergleiche 

Neben den logischen Operationen sind Vergleiche ein wichtiges Konzept, das wir in logischen Ausdrücken regelmässig anwenden. 

Es gibt genau sechs (6) Vergleichsoperatoren:

* Gleich (`==`)
* Ungleich (`!=`)
* Grösser als (`>`)
* Grösser gleich (`>=`)
* Kleiner als (`<`)
* Kleiner gleich (`<=`)

::: {.callout-warning}
Vergleiche erfordern, dass beide Werte vom gleichen Datentyp sind.
:::

Die Vergleiche funktionieren für alle fundamentalen Datentypen.

Bei Zeichenketten wertet R die alphabetische Reihenfolge der Symbole vom Beginn einer Zeichenkette aus, um grösser oder kleiner Vergleiche durchzuführen.

### Die Existenz eines Werts in einem Vektor überprüfen

Häufig müssen Sie überprüfen, ob ein Wert in einer Liste vorkommt. Grundsätzlich können Sie das mit komplizierten logischen Verknüpfungen in der Art von @exm-check-without-in schreiben.

::: {#exm-check-without-in}
## Existstenzprüfung ohne `%in%`
```{r}
meinWert = 3
wertVektor = c(8, 2, 3)

meinWert == wertVektor[1] | meinWert == wertVektor[2] | meinWert == wertVektor[3]
```
:::

Einfacher ist aber ein sogenannter *Existenztest*. Dabei wird überprüft, ob ein Wert in einem Vektor vorkommt. Ein solcher Test lässt sich wie in @exm-check-with-in schreiben: 

::: {#exm-check-with-in}
## Existstenzprüfung mit `%in%`
```{r}
meinWert = 3
wertVektor = c(8, 2, 3)

meinWert %in% wertVektor
```
:::

Entsprechend der Definition des Existenzvergleichs $\in$ funktioniert R's `%in%`-Operator auch für Vektoren als linker Operand.

## Fälle unterscheiden

### Bedingte Operationen

### Vektorisierte Unterscheidungen

## Filtern

## Selektieren

::: {.callout-tip}
## Praxis

Die `tidyverse` Bibliothek umfasst die [`tidyselect`-Funktionen](https://tidyselect.r-lib.org/reference/language.html). Dabei handelt es sich um eine Reihe von Hilfsfunktionen, die die Vektorenauswahl nachvollziehbarer macht. Auf der [`tidyselect`-Homepage](https://tidyselect.r-lib.org/) finden sich ausführliche Code-Beispiele. 
:::

In R können Vektoren mit der Funktion `select()` selektiert werden. Dieser Funktion werden Regeln übergeben, nach denen die Vektoren auswählt werden sollen. Die einfachste Regel ist die direkte Eingabe der Vektorennamen. Ein typischer Anwendungsfall ist die Datenbereinigung, damit die Funktion `drop_na()` nicht zu viele Datensätze löscht. Diese Situation kommt vor, wenn ein Datenrahmen viele fehlende Werte enthält, die ungleichmässig in den Vektoren vorkommen. Die Analyse muss deshalb auf die gewünschten Vektoren beschränkt werden. 

Für die folgenden Beispiele verwenden wir die Daten der Befragung zum digitalen Umfeld, die mit der `read_delim()`-Funktion eingelesen wird. 

```{r}
stichprobe = read_delim("daten/befragung_digitales_umfeld/deviceuse.csv") 
```

### Vektoren direkt selektieren

Wir wollen die Vektoren `q00_demo_gen` (Gender), `q00_demo_studyload` (Studienmodell) und `q01_mob_typ` (Mobile OS des Smartphones) auswählen. 

::: {#exm-select-direkt}
## Direktes selektieren
```{r}
stichprobe |>
    select(q00_demo_gen, q00_demo_studyload, q01_mob_typ) |>
    head()
```
:::

Durch diesen Aufruf von `select()` wird der Datenrahmen auf die drei ausgewählten Vektoren reduziert. 

### Alle ausser die benannten Vektoren selektieren

Vektoren direkt zu benennen ist eine einfache direkte Methode. Wenn man sehr viele Vektoren auswählen möchte, dann ist es manchmal einfacher, nur die Vektoren anzugeben, die *nicht* in der Ergebnisstichprobe enthalten sein sollen. Mit `select()` erreichen wir das, indem wir ein `-` den ungewollten Vektoren voranstellen. 

Das folgende Beispiel selektiert alle Vektoren ausser `q00_demo_gen` aus der Stichprobe. 

::: {#exm-select-direkt-neg}
## Selektieren durch Ausschliessen
```R
stichprobe |>
    select(-q00_demo_gen) |>
    head()
```
:::

Wenn  mehrere Vektoren ausgeschlossen werden sollen, dann müssen diese zu einem Vektor zusammengefasst werden. 

::: {#exm-select-direkt-neg-multi}
## Selektieren durch mehrfaches Ausschliessen
```R
stichprobe |>
    select(- c(q00_demo_gen, q00_demo_studyload)) |>
    head()
```
:::

Diese Vektorenauswahl wählt alle Vektoren ausser das Geschlecht und das Studienmodell. 

### Vektoren mit ähnlichen Namen auswählen

Drei leistungsfähige Hilfsfunktionen für `select()` sind: 

- `starts_with()`,
- `ends_with()` sowie
- `contains()`

Diesen Funktionen akzeptieren einen Teilnamen, über den mehrere Vektoren ausgewählt werden, in denen der angegebene Teil im Vektornamen vorkommt. 

Diese Funktionen lassen sich mittels der `iris`-Stichprobe  veranschaulichen.

::: {#exm-select-starts-with}
## Selektieren mit `starts_with()`
```{r}
iris %>%
    select(starts_with("Sepal")) |>  # wählt die Vektoren Sepal.Width und Sepal.Length aus
    head()
```
:::

::: {#exm-select-ends-with}
## Selektieren mit `ends_with()`

```{r}
iris %>%
    select(ends_with("Length")) |> # wählt die Vektoren Petal.Length und Sepal.Length aus
    head()
```
:::

### Alle Vektoren zwischen zwei benannten Vektoren auswählen

Eine weitere Möglichkeit schneller viele Vektoren auszuwählen ist der `:`-Operator. Damit können wir alle Vektoren zwischen zwei Vektoren inklusive der benannten Vektoren auswählen.

Der folgende Aufruf veranschaulicht dies: 
::: {#exm-select-range}
## Vektorenbereich selektieren
```{r}
stichprobe |>
    select(q00_demo_gen:q01_mob_typ) |>
    head()
```
:::

Diese Vektorenauswahl wählt die Vektoren `q00_demo_gen`, `q00_demo_studyload` und `q01_mob_typ` für das Ergebnis aus.

::: {.callout-warning}
Die Reihenfolge von Vektoren kann durch andere Transformationen geändert werden. Deshalb sollte das Selektieren mit Vektorbereichen vermieden werden.
:::


## Sortieren
